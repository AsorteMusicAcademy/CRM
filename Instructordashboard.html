const { onCall, HttpsError } = require("firebase-functions/v2/https");
const { initializeApp } = require("firebase-admin/app");
const { getFirestore, FieldValue } = require("firebase-admin/firestore");
const { getAuth } = require("firebase-admin/auth");
const { google } = require("googleapis");
const stripeLib = require("stripe");

initializeApp();
const db = getFirestore();
const adminAuth = getAuth();

// --- Function for Admin App ---

exports.getStripeFinancials = onCall({ secrets: ["STRIPE_SECRET"], cors: true }, async (request) => {
  const stripe = new stripeLib(process.env.STRIPE_SECRET);
  const { startDate, endDate } = request.data;
  if (!startDate || !endDate) {
    throw new HttpsError('invalid-argument', 'The function must be called with "startDate" and "endDate".');
  }
  try {
    const startTimestamp = Math.floor(new Date(startDate).getTime() / 1000);
    const endTimestamp = Math.floor(new Date(endDate).getTime() / 1000);
    const charges = await stripe.charges.list({
      created: { gte: startTimestamp, lte: endTimestamp },
      expand: ["data.balance_transaction"],
      limit: 100,
    });
    const successfulCharges = charges.data.filter((charge) => charge.paid && !charge.refunded);
    const paymentPromises = successfulCharges.map(async (charge) => {
      let customerName = "Guest Customer";
      let customerEmail = "N/A";
      if (charge.customer) {
        try {
          const customer = await stripe.customers.retrieve(charge.customer);
          customerName = customer.name || customer.email || "Unknown Customer";
          customerEmail = customer.email || "N/A";
        } catch (customerError) {
          console.warn(`Could not retrieve customer ${charge.customer}:`, customerError.message);
        }
      } else {
         customerName = charge.billing_details.name || charge.receipt_email || "Guest Customer";
         customerEmail = charge.receipt_email || charge.billing_details.email || "N/A";
      }
      const fee = charge.balance_transaction ? charge.balance_transaction.fee / 100 : 0;
      const netAmount = (charge.amount / 100) - fee;
      return {
        date: new Date(charge.created * 1000).toISOString(),
        customer: customerName,
        email: customerEmail,
        description: charge.description || 'Abonament',
        amount: charge.amount / 100,
        net: netAmount,
      };
    });
    const payments = await Promise.all(paymentPromises);
    return { payments };
  } catch (error) {
    console.error("Stripe API Error:", error);
    throw new HttpsError('internal', 'Unable to fetch data from Stripe.', error.message);
  }
});


// --- Functions for Client Portal ---

async function getLastPayment(clientData) {
    const stripe = new stripeLib(process.env.STRIPE_SECRET);
    const allPayments = [];
    if (clientData.email) {
        try {
            const customers = await stripe.customers.list({ email: clientData.email, limit: 1 });
            if (customers.data.length > 0) {
                const charges = await stripe.charges.list({ customer: customers.data[0].id, limit: 10 });
                charges.data
                    .filter(c => c.paid && !c.refunded)
                    .forEach(c => {
                        allPayments.push({
                            date: new Date(c.created * 1000),
                            text: `${(c.amount / 100).toFixed(2)} RON (${new Date(c.created * 1000).toLocaleDateString('ro-RO')} via Stripe)`
                        });
                    });
            }
        } catch (error) { console.error("Error fetching Stripe payments for client:", error.message); }
    }
    try {
        const paymentsRef = db.collection('payments');
        const snapshot = await paymentsRef.where('clientName', '==', clientData.name).get();
        snapshot.forEach(doc => {
            const data = doc.data();
            allPayments.push({
                date: new Date(data.created),
                text: `${data.amount.toFixed(2)} RON (${new Date(data.date).toLocaleDateString('ro-RO')} via Cash)`
            });
        });
    } catch (error) { console.error("Error fetching Firestore payments for client:", error); }
    if (allPayments.length === 0) return null;
    allPayments.sort((a, b) => b.date - a.date);
    return allPayments[0].text;
}

async function getSessionHistory(calendar, clientName) {
    const timeMax = new Date().toISOString();
    const timeMin = new Date(new Date().setDate(new Date().getDate() - 90)).toISOString();
    let history = [];
    try {
        const response = await calendar.events.list({
            calendarId: "asorteoffice@gmail.com",
            timeMin, timeMax, q: `"${clientName}"`, singleEvents: true, orderBy: "startTime", showDeleted: true,
        });
        if (response.data.items) {
            history = response.data.items.map(event => {
                let status = "Efectuată";
                const organizer = event.attendees?.find(a => a.organizer);
                if (organizer?.responseStatus === 'declined' || event.status === 'cancelled') {
                    status = "Anulată";
                }
                return { summary: event.summary || "Eveniment fără titlu", date: event.start?.dateTime || event.start?.date, status };
            }).sort((a, b) => new Date(b.date) - new Date(a.date));
        }
    } catch (error) { console.error("Error fetching session history:", error); }
    return history;
}

exports.getClientPortalData = onCall({ secrets: ["STRIPE_SECRET"], cors: true }, async (request) => {
    if (!request.auth) throw new HttpsError("unauthenticated", "You must be logged in.");
    const email = request.auth.token.email;
    if (!email) throw new HttpsError("invalid-argument", "Token is missing an email.");
    const snapshot = await db.collection("clients").where("email", "==", email).limit(1).get();
    if (snapshot.empty) throw new HttpsError("not-found", "No client record found.");
    const clientData = snapshot.docs[0].data();
    const auth = new google.auth.GoogleAuth({ scopes: ["https://www.googleapis.com/auth/calendar.readonly"] });
    const calendar = google.calendar({ version: "v3", auth });
    const timeMin = new Date().toISOString();
    const timeMax = new Date(new Date().setDate(new Date().getDate() + 30)).toISOString();
    let upcomingSessions = [];
    try {
        const response = await calendar.events.list({ calendarId: "asorteoffice@gmail.com", timeMin, timeMax, q: `"${clientData.name}"`, singleEvents: true, orderBy: "startTime" });
        upcomingSessions = response.data.items.filter(event => {
            if (event.status === 'cancelled') return false;
            const organizer = event.attendees?.find(a => a.organizer);
            return organizer?.responseStatus !== 'declined';
        }).map(e => ({ summary: e.summary, start: e.start, end: e.end, discipline: e.summary.split(' - ')[1] || clientData.discipline }));
    } catch (error) { console.error("Error fetching Google Calendar events:", error); }
    const lastEvent = await getLastSessionEvent(calendar, clientData.name);
    let sessionNumber = 0;
    if (lastEvent && lastEvent.summary) {
        const parts = lastEvent.summary.split(' - ').map(p => p.trim());
        if (parts.length >= 3) {
            const parsedNumber = parseInt(parts[2].toLowerCase().replace('sedinta', '').replace('#', ''), 10);
            if (!isNaN(parsedNumber)) sessionNumber = parsedNumber;
        }
    }
    const lastPayment = await getLastPayment(clientData);
    const history = await getSessionHistory(calendar, clientData.name);
    return { name: clientData.name, discipline: clientData.discipline, courseId: clientData.courseId || null, youtubePlaylist: clientData.youtubePlaylist || [], sessionNumber, subscriptionType: clientData.subscription || '4', nextSessions: upcomingSessions, lastPayment, history };
});

async function getLastSessionEvent(calendar, clientName) {
    const timeMax = new Date().toISOString();
    const timeMin = new Date(new Date().setDate(new Date().getDate() - 60)).toISOString();
    try {
        const response = await calendar.events.list({ calendarId: "asorteoffice@gmail.com", timeMin, timeMax, q: `"${clientName}" "Sedinta"`, singleEvents: true, orderBy: "startTime", showDeleted: false });
        const events = response.data.items.filter(event => {
            if (event.status === 'cancelled') return false;
            const organizer = event.attendees?.find(a => a.organizer);
            return organizer?.responseStatus !== 'declined';
        });
        return events.length > 0 ? events[events.length - 1] : null;
    } catch (error) { console.error("Error fetching last session event:", error); return null; }
}

exports.updateClientPlaylist = onCall({ cors: true }, async (request) => {
    if (!request.auth) throw new HttpsError("unauthenticated", "You must be logged in.");
    const email = request.auth.token.email;
    const { playlist } = request.data;
    if (!Array.isArray(playlist)) throw new HttpsError("invalid-argument", "'playlist' must be an array.");
    const snapshot = await db.collection("clients").where("email", "==", email).limit(1).get();
    if (snapshot.empty) throw new HttpsError("not-found", "No client record found.");
    await snapshot.docs[0].ref.update({ youtubePlaylist: playlist });
    return { success: true };
});


// --- Functions for Instructor App ---

exports.getInstructorDashboard = onCall({ cors: true }, async (request) => {
    if (!request.auth) throw new HttpsError("unauthenticated", "You must be logged in.");
    const instructorUID = request.auth.uid;
    const userRecord = await adminAuth.getUser(instructorUID);
    const instructorEmail = userRecord.email;
    const instructorSnapshot = await db.collection('instructors').where('Email', '==', instructorEmail).limit(1).get();
    if (instructorSnapshot.empty) throw new HttpsError("not-found", "The logged-in user is not a registered instructor in the database.");
    const instructorName = instructorSnapshot.docs[0].data().name;
    let allTodaysEvents = [];
    try {
        const today = new Date();
        const timeMin = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0).toISOString();
        const timeMax = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59).toISOString();
        const auth = new google.auth.GoogleAuth({ scopes: ["https://www.googleapis.com/auth/calendar.readonly"] });
        const calendar = google.calendar({ version: "v3", auth });
        const response = await calendar.events.list({ calendarId: "asorteoffice@gmail.com", timeMin, timeMax, singleEvents: true, orderBy: 'startTime' });
        allTodaysEvents = response.data.items.filter(event => {
            if (event.status === 'cancelled') return false;
            const organizer = event.attendees?.find(a => a.organizer);
            return organizer?.responseStatus !== 'declined';
        });
    } catch (error) {
        console.error("Google Calendar API Error:", error);
        if (error.code === 403) throw new HttpsError("permission-denied", "The service account lacks permission for Google Calendar.");
        throw new HttpsError("internal", "Could not fetch calendar schedule.");
    }
    const clientsSnapshot = await db.collection('clients').where('assignedInstructor', '==', instructorName).get();
    const assignedClientsData = clientsSnapshot.docs.reduce((acc, doc) => {
        acc[doc.data().name] = doc.data();
        return acc;
    }, {});
    const instructorClientsForToday = allTodaysEvents.map(event => {
        if (!event.summary) return null;
        const eventClientName = event.summary.split(' - ')[0].trim();
        const clientData = assignedClientsData[eventClientName];
        if (clientData) {
            const sessionPart = event.summary.split(' - ')[2] || '';
            const parsedNumber = parseInt(sessionPart.toLowerCase().replace('sedinta', '').replace('#', ''), 10);
            return {
                name: clientData.name, discipline: clientData.discipline, startTime: event.start.dateTime || event.start.date,
                sessionNumber: isNaN(parsedNumber) ? 0 : parsedNumber, subscriptionType: clientData.subscription || '4',
                youtubePlaylist: clientData.youtubePlaylist || [], homework: clientData.homework || [],
            };
        }
        return null;
    }).filter(Boolean);
    return { instructorName, clients: instructorClientsForToday };
});

exports.addHomeworkForClientInsecure = onCall({ cors: true }, async (request) => {
    const { instructorName, clientName, homeworkText } = request.data;
    if (!instructorName || !clientName || !homeworkText) throw new HttpsError("invalid-argument", "Missing required fields.");
    const clientSnapshot = await db.collection('clients').where('name', '==', clientName).limit(1).get();
    if (clientSnapshot.empty) throw new HttpsError("not-found", "Client not found.");
    const clientData = clientSnapshot.docs[0].data();
    if (clientData.assignedInstructor !== instructorName) throw new HttpsError("permission-denied", "You are not assigned to this client.");
    await clientSnapshot.docs[0].ref.update({
        homework: FieldValue.arrayUnion({ text: homeworkText, date: new Date().toISOString() }),
    });
    return { success: true };
});

exports.updatePlaylistForClientInsecure = onCall({ cors: true }, async (request) => {
    const { instructorName, clientName, playlist } = request.data;
    if (!instructorName || !clientName || !Array.isArray(playlist)) throw new HttpsError("invalid-argument", "Missing required fields.");
    const clientSnapshot = await db.collection('clients').where('name', '==', clientName).limit(1).get();
    if (clientSnapshot.empty) throw new HttpsError("not-found", "Client not found.");
    const clientData = clientSnapshot.docs[0].data();
    if (clientData.assignedInstructor !== instructorName) throw new HttpsError("permission-denied", "You are not assigned to this client.");
    await clientSnapshot.docs[0].ref.update({ youtubePlaylist: playlist });
    return { success: true };
});

// **NEW FUNCTION FOR INSTRUCTOR TIMESHEET**
exports.getInstructorTimesheet = onCall({ secrets: ["STRIPE_SECRET"], cors: true }, async (request) => {
    if (!request.auth) {
        throw new HttpsError("unauthenticated", "You must be logged in.");
    }
    const instructorUID = request.auth.uid;
    const userRecord = await adminAuth.getUser(instructorUID);
    const instructorEmail = userRecord.email;

    const instructorSnapshot = await db.collection('instructors').where('Email', '==', instructorEmail).limit(1).get();
    if (instructorSnapshot.empty) {
        throw new HttpsError("not-found", "The logged-in user is not a registered instructor.");
    }
    const instructorDoc = instructorSnapshot.docs[0];
    const instructorId = instructorDoc.id;
    const instructorName = instructorDoc.data().name;

    // Fetch the specific timesheet document for this instructor
    const timesheetDoc = await db.collection('timesheets').doc(instructorId).get();
    const timesheetData = timesheetDoc.exists ? timesheetDoc.data() : { sessions: {} };

    // Fetch instructor percentages
    const percentagesDoc = await db.collection('app-settings').doc('instructor-percentages').get();
    const instructorPercentages = percentagesDoc.exists ? percentagesDoc.data() : {};
    
    return {
        instructor: { id: instructorId, name: instructorName },
        timesheet: timesheetData,
        instructorPercentages
    };
});
