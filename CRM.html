<!DOCTYPE html>
<html lang="ro" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestionare Sesiuni Clienți</title>

    <script src="https://accounts.google.com/gsi/client" async defer></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Simple debounce status indicator */
        .notes-status,
        .sub-status {
            transition: opacity 0.3s ease-in-out;
        }

        /* Modal styles */
        .modal-overlay {
            transition: opacity 0.3s ease;
        }

        .modal-content {
            transition: transform 0.3s ease;
        }

        /* Custom scrollbar for better aesthetics in dark mode */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1f2937;
            /* gray-800 */
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            /* gray-600 */
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
            /* gray-500 */
        }

        /* Ensure table layout is fixed for reports */
        .report-table {
            table-layout: fixed;
            width: 100%;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200">

    <div id="client-tracker-widget" class="container mx-auto p-4 sm:p-6 lg:p-8">

        <header class="relative text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-bold text-gray-100">Gestionare Sesiuni Clienți</h1>
            <p class="text-lg text-gray-400 mt-2">Gestionează sesiunile clienților din Google Calendar & Classroom</p>
        </header>

        <div id="main-app-view">
            <div id="config-section" class="max-w-4xl mx-auto bg-gray-800 p-6 rounded-xl shadow-md space-y-4 mb-8">

                <div id="auth-section">
                    <p class="text-center text-gray-400 mb-4">Te rugăm să te autentifici și să autorizezi aplicația
                        pentru a accesa datele din Google Calendar și Classroom.</p>
                    <button id="authBtn"
                        class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-4 focus:ring-purple-300 transition-all duration-300 ease-in-out flex items-center justify-center">
                        <svg class="h-6 w-6 mr-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"
                            width="24px" height="24px">
                            <path
                                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                                fill="#4285F4" />
                            <path
                                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                                fill="#34A853" />
                            <path
                                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l3.66-2.84z"
                                fill="#FBBC05" />
                            <path
                                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                                fill="#EA4335" />
                            <path d="M1 1h22v22H1z" fill="none" />
                        </svg>
                        Autentificare și Autorizare cu Google
                    </button>

                    <div class="relative flex py-5 items-center">
                        <div class="flex-grow border-t border-gray-600"></div>
                        <span class="flex-shrink mx-4 text-gray-400">SAU</span>
                        <div class="flex-grow border-t border-gray-600"></div>
                    </div>

                    <div class="text-center mb-4">
                        <a href="#" id="testing-mode-toggle"
                            class="text-sm text-blue-400 hover:underline cursor-pointer">Intră în Modul de Testare</a>
                    </div>

                    <div id="manual-auth-section" style="display: none;">
                        <p class="text-center text-gray-400 mb-4">Pentru testare, introdu un token de acces OAuth 2.0 de
                            pe <a href="https://developers.google.com/oauthplayground" target="_blank"
                                class="text-blue-400 hover:underline">Google OAuth Playground</a>.</p>
                        <div class="flex items-center space-x-2">
                            <input type="password" id="manualAccessToken" placeholder="Introdu Token-ul de Acces Aici"
                                class="flex-grow px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="submitTokenBtn"
                                class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors">
                                Trimite
                            </button>
                        </div>
                    </div>
                </div>

                <hr id="config-hr" class="border-gray-600" style="display: none;" />

                <div id="main-config-controls" style="display: none;">
                    <div class="space-y-6">
                        <div>
                            <label for="calendarId" class="block text-sm font-medium text-gray-300 mb-1">ID Google
                                Calendar</label>
                            <div class="flex items-center space-x-2">
                                <input type="email" id="calendarId" value="asorteoffice@gmail.com"
                                    placeholder="ex: primary sau user@exemplu.com"
                                    class="flex-grow px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <button id="openCalendarBtn" title="Deschide Calendarul într-un Tab Nou"
                                    class="bg-blue-600 text-white p-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-blue-500 transition-colors">
                                    <i data-lucide="external-link" class="h-5 w-5"></i>
                                </button>
                            </div>
                        </div>

                        <div id="tab-controls" class="space-y-4">
                            <div class="flex flex-wrap items-center justify-center gap-2">
                                <button data-tab="dashboard" class="tab-button"></button>
                                <button data-tab="add" class="tab-button"></button>
                                <button data-tab="today" class="tab-button"></button>
                                <button data-tab="tomorrow" class="tab-button"></button>
                                <button data-tab="all" class="tab-button"></button>
                                <button data-tab="instructors" class="tab-button"></button>
                                <button data-tab="financials" class="tab-button"></button>
                                <button data-tab="reports" class="tab-button"></button>
                                <button data-tab="timesheet" class="tab-button"></button>
                                <button data-tab="settings" class="tab-button"></button>
                            </div>
                        </div>

                        <div class="relative filter-control">
                            <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3"><i
                                    data-lucide="search" class="h-5 w-5 text-gray-400"></i></div>
                            <input type="text" id="searchQuery" placeholder="Caută client global..."
                                class="block w-full rounded-md border-gray-600 bg-gray-700 pl-10 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-3">
                        </div>

                        <div class="flex flex-wrap gap-4 filter-control">
                            <div class="flex-1 min-w-[200px]">
                                <label for="disciplineFilter"
                                    class="block text-sm font-medium text-gray-300 mb-1">Filtrează după
                                    Disciplină</label>
                                <select id="disciplineFilter"
                                    class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </select>
                            </div>

                            <div class="flex items-end pb-1">
                                <label for="lastSessionFilter" class="flex items-center space-x-2 cursor-pointer">
                                    <input type="checkbox" id="lastSessionFilter"
                                        class="h-4 w-4 rounded border-gray-500 bg-gray-700 text-blue-600 focus:ring-blue-500">
                                    <span class="text-sm font-medium text-gray-300">Afișează doar clienții în ultima
                                        ședință</span>
                                </label>
                            </div>
                        </div>

                        <div class="mt-4 space-y-2">
                            <button id="incrementAllBtn"
                                class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 disabled:bg-gray-400 transition-all duration-300 ease-in-out hidden">
                                Incrementează Toate Sesiunile pentru Mâine
                            </button>
                            <button id="logTodaysSessionsBtn"
                                class="w-full bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-cyan-700 focus:outline-none focus:ring-4 focus:ring-cyan-300 disabled:bg-gray-400 transition-all duration-300 ease-in-out hidden">
                                Înregistrează Pontajul de Azi
                            </button>
                        </div>

                    </div>
                </div>
            </div>

            <div id="notification-area" class="max-w-7xl mx-auto mb-6"></div>

            <div id="results-area" class="max-w-7xl mx-auto">
            </div>
        </div>
    </div>

    <div id="cancel-modal"
        class="modal-overlay fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-md transform scale-95">
            <h3 class="text-2xl font-bold text-white mb-4">Confirmă Anularea</h3>
            <p class="text-gray-400 mb-6">Cine anulează această sesiune?</p>
            <div class="space-y-3">
                <button id="cancel-by-instructor-btn"
                    class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors">
                    Anulată de Instructor
                </button>
                <button id="cancel-by-client-btn"
                    class="w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700 focus:outline-none focus:ring-4 focus:ring-red-300 transition-colors">
                    Anulată de Client
                </button>
            </div>
            <button id="close-modal-btn"
                class="mt-6 w-full text-gray-400 hover:text-white font-medium py-2 px-4 rounded-lg transition-colors">
                Renunță
            </button>
        </div>
    </div>

    <div id="create-event-modal"
        class="modal-overlay fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-lg transform scale-95">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold text-white">Adaugă Programare Nouă</h3>
                <button id="close-create-modal-btn" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="h-6 w-6"></i>
                </button>
            </div>
            <form id="create-event-form" class="space-y-4">
                <input type="hidden" id="event-start-time">
                <input type="hidden" id="event-end-time">
                <div>
                    <label for="event-time-display" class="block text-sm font-medium text-gray-300 mb-1">Interval
                        Orar</label>
                    <input type="text" id="event-time-display" disabled
                        class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="client-name" class="block text-sm font-medium text-gray-300 mb-1">Nume Client</label>
                    <input type="text" id="client-name" required
                        class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="client-phone" class="block text-sm font-medium text-gray-300 mb-1">Telefon
                        Client</label>
                    <input type="tel" id="client-phone" required
                        class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="client-email" class="block text-sm font-medium text-gray-300 mb-1">Email Client</label>
                    <input type="email" id="client-email" required
                        class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="event-discipline"
                        class="block text-sm font-medium text-gray-300 mb-1">Disciplina</label>
                    <select id="event-discipline" required
                        class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </select>
                </div>
                <div class="flex justify-end pt-4">
                    <button type="submit" id="submit-event-btn"
                        class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors flex items-center">
                        <i data-lucide="plus-circle" class="h-5 w-5 mr-2"></i>
                        Creează Eveniment
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div id="cash-payment-modal"
        class="modal-overlay fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden z-50">
        <div class="modal-content bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-md transform scale-95">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold text-white">Înregistrează Plată Cash</h3>
                <button id="close-cash-modal-btn" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="h-6 w-6"></i>
                </button>
            </div>
            <form id="cash-payment-form" class="space-y-4">
                <input type="hidden" id="cash-client-name">
                <input type="hidden" id="cash-event-id">
                <div>
                    <label for="cash-client-name-display"
                        class="block text-sm font-medium text-gray-300 mb-1">Client</label>
                    <input type="text" id="cash-client-name-display" disabled
                        class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="cash-amount" class="block text-sm font-medium text-gray-300 mb-1">Sumă (RON)</label>
                    <input type="number" id="cash-amount" required
                        class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="ex: 250">
                </div>
                <div class="flex justify-end pt-4">
                    <button type="submit" id="submit-cash-payment-btn"
                        class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-colors flex items-center">
                        <i data-lucide="save" class="h-5 w-5 mr-2"></i>
                        Salvează Plata
                    </button>
                </div>
            </form>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, getDocs, deleteDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAOWN00AgCvIRaQSuspNAZCl-GM97LoCSk",
            authDomain: "asorte-crm.firebaseapp.com",
            projectId: "asorte-crm",
            storageBucket: "asorte-crm.appspot.com",
            messagingSenderId: "848279125018",
            appId: "1:848279125018:web:3788d9a7be3b7d2456a5a3"
        };

        // --- Firebase Initialization ---
        let app, auth, db, userId;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log("Firebase initialized successfully");
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            renderNotification("Firebase initialization failed. Please check your configuration.", "error");
        }

        onAuthStateChanged(auth, user => {
            if (user) {
                userId = user.uid;
                console.log("User is signed in with UID:", userId);
            } else {
                signInAnonymously(auth).catch(error => {
                    console.error("Anonymous sign-in failed:", error);
                });
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            // --- Google Sign-In Configuration ---
            const GOOGLE_CLIENT_ID = '1042460892509-gmoih87sc14vmkc4td34bal6h8cbjgof.apps.googleusercontent.com';
            const SCOPES = 'https://www.googleapis.com/auth/calendar https://www.googleapis.com/auth/classroom.coursework.students https://www.googleapis.com/auth/classroom.courses.readonly';

            // --- STATE MANAGEMENT ---
            let state = {
                accessToken: null,
                calendarId: 'asorteoffice@gmail.com',
                clients: {},
                clientFirebaseData: {}, // Holds Firestore data for clients
                courses: null,
                instructors: [],
                instructorPercentages: {}, // Percentage for each instructor
                activeTab: 'dashboard',
                searchQuery: '',
                isLoading: false,
                isSearching: false,
                fetched: false,
                expandedClient: null,
                activeDiscipline: 'all',
                filterLastSessionOnly: false,
                cancellationContext: null,
                cashPaymentContext: null, // NEW: Context for cash payments
                timesheet: {}, // To store timesheet data by instructorId
                timesheetFilter: { month: new Date().getMonth(), year: new Date().getFullYear() }, // NEW: Filter for timesheet
                timesheetClientData: {}, //  To store client data for timesheet
                initialInstructorsLoaded: false, // Flag to track initial instructor load
                isSettingsExpanded: false, // For settings accordion
                isWorkingHoursExpanded: false, // For working hours accordion
                isDoubleBookingExpanded: false, // For double booking accordion
                isApiKeysExpanded: false, // For API Keys accordion
                financials: { // State for the financials tab
                    allPayments: [],
                    filteredPayments: [],
                    searchQuery: ''
                },
                disciplinesForBooking: [ // Updated list for the new event form
                    'Chitară', 'Canto', 'Pian', 'Bas', 'Tobe', 'Productie'
                ],
                workingHours: {
                    'Luni': { enabled: true, startTime: 9, endTime: 21 },
                    'Marți': { enabled: true, startTime: 9, endTime: 21 },
                    'Miercuri': { enabled: true, startTime: 9, endTime: 21 },
                    'Joi': { enabled: true, startTime: 9, endTime: 21 },
                    'Vineri': { enabled: true, startTime: 9, endTime: 21 },
                    'Sâmbătă': { enabled: true, startTime: 9, endTime: 21 },
                },
                doubleBookingRules: { // Default rule
                    'Miercuri': { enabled: true, startTime: 14, endTime: 21 }
                },
                messageTemplates: { // Default WhatsApp message templates
                    notification: `Salut {Nume}! Te contactăm pentru a-ți confirma prezența la cursul de {Disciplina} programat pentru {Data}, la ora {Ora}. Îți mulțumim și te așteptăm cu drag!`,
                    lastSession: `Salut {Nume}! Îți reamintim cu drag că sesiunea de {Data} este ultima din abonamentul tău. Poți face plata accesând acest link: https://www.asortemediaproductions.com/paginapreturi. O zi frumoasă!`,
                    newSubscription: `Salut {Nume}! Îți reamintim cu drag că următoarea ședință este prima dintr-un nou abonament și necesită o nouă plată. Poți face plata accesând acest link: https://www.asortemediaproductions.com/paginapreturi. O zi frumoasă!`,
                    cancelByInstructor: `Salut {Nume}! Ne cerem scuze că a trebuit să anulăm ședința ta de {Disciplina} programată pentru {Data}, la ora {Ora}. Îți mulțumim pentru înțelegere și vrem să te înștiințăm că această ședință nu va fi luată în calcul la abonamentul curent!`,
                    cancelByClient: `Ședința ta de {Disciplina} de {Data}, ora {Ora}, a fost anulată. Menționăm că, deoarece anularea a avut loc cu mai puțin de 48 de ore înainte, sesiunea va fi considerată ca fiind efectuată.`
                },
            };

            // --- DOM ELEMENT REFERENCES ---
            const dom = {
                mainAppView: document.getElementById('main-app-view'),
                authBtn: document.getElementById('authBtn'),
                calendarIdInput: document.getElementById('calendarId'),
                searchQueryInput: document.getElementById('searchQuery'),
                incrementAllBtn: document.getElementById('incrementAllBtn'),
                notificationArea: document.getElementById('notification-area'),
                resultsArea: document.getElementById('results-area'),
                tabControls: document.getElementById('tab-controls'),
                tabButtons: document.querySelectorAll('.tab-button'),
                disciplineFilter: document.getElementById('disciplineFilter'),
                filterControls: document.querySelectorAll('.filter-control'),
                lastSessionFilter: document.getElementById('lastSessionFilter'),
                openCalendarBtn: document.getElementById('openCalendarBtn'),
                cancelModal: document.getElementById('cancel-modal'),
                modalContent: document.querySelector('#cancel-modal .modal-content'),
                cancelByInstructorBtn: document.getElementById('cancel-by-instructor-btn'),
                cancelByClientBtn: document.getElementById('cancel-by-client-btn'),
                closeModalBtn: document.getElementById('close-modal-btn'),
                createEventModal: document.getElementById('create-event-modal'),
                createEventForm: document.getElementById('create-event-form'),
                closeCreateModalBtn: document.getElementById('close-create-modal-btn'),
                submitEventBtn: document.getElementById('submit-event-btn'),
                // NEW: Cash Payment Modal elements
                cashPaymentModal: document.getElementById('cash-payment-modal'),
                cashPaymentForm: document.getElementById('cash-payment-form'),
                closeCashModalBtn: document.getElementById('close-cash-modal-btn'),
                submitCashPaymentBtn: document.getElementById('submit-cash-payment-btn'),
            };

            // --- DEBOUNCE UTILITY ---
            const debounce = (func, delay) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), delay);
                };
            };

            // --- HELPER FUNCTIONS ---
            const replacePlaceholders = (template, data) => {
                if (!template) return '';
                return template
                    .replace(/{Nume}/g, data.name || '')
                    .replace(/{Disciplina}/g, data.discipline || '')
                    .replace(/{Data}/g, data.date || '')
                    .replace(/{Ora}/g, data.time || '');
            };

            const sanitizeForFirestoreId = (text) => {
                if (!text) return '';
                // Replace characters that are invalid for Firestore document IDs.
                // Most notably, forward slashes.
                return text.replace(/\//g, '-');
            };

            // --- FIRESTORE API ---
            const firestoreApi = {
                async getClientData(clientName) {
                    if (!db || !clientName) return { notes: '', subscription: '4', assignedInstructor: '' };
                    const sanitizedName = sanitizeForFirestoreId(clientName);
                    const docRef = doc(db, "clients", sanitizedName);
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        return { name: clientName, ...data, subscription: data.subscription || '4', assignedInstructor: data.assignedInstructor || '' };
                    } else {
                        return { name: clientName, notes: '', subscription: '4', assignedInstructor: '' };
                    }
                },
                async saveClientData(clientName, data) {
                    if (!db || !clientName) return;
                    const sanitizedName = sanitizeForFirestoreId(clientName);
                    const docRef = doc(db, "clients", sanitizedName);
                    await setDoc(docRef, data, { merge: true });
                },
                async addInstructor(name, phone) {
                    if (!db || !name) return;
                    await addDoc(collection(db, "instructors"), { name, phone });
                },
                async updateInstructor(id, data) {
                    if (!db || !id) return;
                    const docRef = doc(db, "instructors", id);
                    await updateDoc(docRef, data);
                },
                async deleteInstructor(id) {
                    if (!db || !id) return;
                    await deleteDoc(doc(db, "instructors", id));
                },
                getInstructors(callback) {
                    if (!db) return () => { };
                    const q = collection(db, "instructors");
                    return onSnapshot(q, (querySnapshot) => {
                        const instructors = [];
                        querySnapshot.forEach((doc) => {
                            instructors.push({ id: doc.id, ...doc.data() });
                        });
                        callback(instructors);
                    });
                },
                async logCashPayment(clientName, amount, paymentDate) {
                    if (!db || !clientName || !amount) return;
                    const paymentsCollection = collection(db, "payments");
                    await addDoc(paymentsCollection, {
                        clientName: clientName,
                        amount: parseFloat(amount),
                        date: paymentDate,
                        method: 'Cash',
                        description: 'Plată cash înregistrată',
                        created: new Date().toISOString()
                    });
                },
                async deleteCashPayment(paymentId) {
                    if (!db || !paymentId) return;
                    await deleteDoc(doc(db, "payments", paymentId));
                },
                async getTimesheetData() {
                    if (!db) return {};
                    const timesheets = {};
                    const snapshot = await getDocs(collection(db, "timesheets"));
                    snapshot.forEach(doc => {
                        timesheets[doc.id] = doc.data();
                    });
                    return timesheets;
                },
                async logDailyTimesheet(instructorId, dateKey, dailyData) { // dailyData = { totalCommission, sessionList }
                    if (!db || !instructorId || !dateKey || !dailyData) return;
                    const docRef = doc(db, "timesheets", instructorId);
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists()) {
                        // Document exists, update the sessions map with the new daily data object
                        await updateDoc(docRef, {
                            [`sessions.${dateKey}`]: dailyData
                        });
                    } else {
                        // Document doesn't exist, create it with the new structure
                        const instructor = state.instructors.find(i => i.id === instructorId);
                        await setDoc(docRef, {
                            instructorName: instructor?.name || 'N/A',
                            sessions: {
                                [dateKey]: dailyData
                            }
                        });
                    }
                },
                async getMessageTemplates() {
                    if (!db) return null;
                    const docRef = doc(db, "app-settings", "whatsapp-templates");
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        return docSnap.data();
                    } else {
                        console.log("No message templates found in Firestore, using defaults.");
                        return null;
                    }
                },
                async saveMessageTemplates(templates) {
                    if (!db) return;
                    const docRef = doc(db, "app-settings", "whatsapp-templates");
                    await setDoc(docRef, templates, { merge: true });
                },
                async getDoubleBookingRules() {
                    if (!db) return null;
                    const docRef = doc(db, "app-settings", "double-booking-rules");
                    const docSnap = await getDoc(docRef);
                    return docSnap.exists() ? docSnap.data() : null;
                },
                async saveDoubleBookingRules(rules) {
                    if (!db) return;
                    const docRef = doc(db, "app-settings", "double-booking-rules");
                    await setDoc(docRef, rules);
                },
                async getWorkingHours() {
                    if (!db) return null;
                    const docRef = doc(db, "app-settings", "working-hours");
                    const docSnap = await getDoc(docRef);
                    return docSnap.exists() ? docSnap.data() : null;
                },
                async saveWorkingHours(hours) {
                    if (!db) return;
                    const docRef = doc(db, "app-settings", "working-hours");
                    await setDoc(docRef, hours);
                },
                async getApiKey(keyName) {
                    if (!db) return null;
                    const docRef = doc(db, "app-settings", "api-keys");
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        return docSnap.data()[keyName] || null;
                    }
                    return null;
                },
                async saveApiKey(keyName, keyValue) {
                    if (!db) return;
                    const docRef = doc(db, "app-settings", "api-keys");
                    await setDoc(docRef, { [keyName]: keyValue }, { merge: true });
                },
                async getInstructorPercentages() {
                    if (!db) return {};
                    const docRef = doc(db, "app-settings", "instructor-percentages");
                    const docSnap = await getDoc(docRef);
                    return docSnap.exists() ? docSnap.data() : {};
                },
                async saveInstructorPercentages(percentages) {
                    if (!db) return;
                    const docRef = doc(db, "app-settings", "instructor-percentages");
                    await setDoc(docRef, percentages);
                },
            };

            // --- Main App Initialization ---
            function initializeAppLogic() {
                if (state.accessToken && !state.courses) {
                    api.fetchCourses()
                        .then(courses => { state.courses = courses; })
                        .catch(err => renderNotification(`Eroare la preluarea cursurilor: ${err.message}`, 'error'));
                }

                attachAppEventListeners();
                updateUI();
                lucide.createIcons();

                // Fetch instructors 
                firestoreApi.getInstructors(instructors => {
                    state.instructors = instructors;
                    if (!state.initialInstructorsLoaded) {
                        state.initialInstructorsLoaded = true;
                        if (state.accessToken) handleTabChange();
                    }
                    if (state.activeTab === 'instructors') {
                        renderInstructorsView();
                    }
                });

                // Fetch message templates
                firestoreApi.getMessageTemplates().then(templates => {
                    if (templates) {
                        state.messageTemplates = { ...state.messageTemplates, ...templates };
                    } else {
                        firestoreApi.saveMessageTemplates(state.messageTemplates);
                    }
                }).catch(err => {
                    console.error("Error fetching message templates:", err);
                    renderNotification("Nu s-au putut încărca șabloanele de mesaje.", "error");
                });

                // Fetch double booking rules
                firestoreApi.getDoubleBookingRules().then(rules => {
                    if (rules) {
                        state.doubleBookingRules = rules;
                    } else {
                        firestoreApi.saveDoubleBookingRules(state.doubleBookingRules);
                    }
                }).catch(err => {
                    console.error("Error fetching double booking rules:", err);
                    renderNotification("Nu s-au putut încărca regulile de rezervare dublă.", "error");
                });

                // Fetch working hours
                firestoreApi.getWorkingHours().then(hours => {
                    if (hours) {
                        state.workingHours = hours;
                    } else {
                        firestoreApi.saveWorkingHours(state.workingHours);
                    }
                }).catch(err => {
                    console.error("Error fetching working hours:", err);
                    renderNotification("Nu s-au putut încărca setările pentru programul de lucru.", "error");
                });
                // Fetch instructor percentages
                firestoreApi.getInstructorPercentages().then(percentages => {
                    if (percentages) {
                        state.instructorPercentages = percentages;
                    }
                    // Re-render instructors view if it's active, to show the loaded percentages
                    if (state.activeTab === 'instructors') {
                        renderInstructorsView();
                    }
                }).catch(err => {
                    console.error("Error fetching instructor percentages:", err);
                    renderNotification("Nu s-au putut încărca procentajele instructorilor.", "error");
                });
            }

            // --- Google Calendar & Classroom API ---
            const api = {
                async getEventsForDateRange(startDate, endDate, showDeleted = false) {
                    const params = new URLSearchParams({
                        singleEvents: 'true',
                        orderBy: 'startTime',
                        maxResults: '2500',
                        timeMin: startDate.toISOString(),
                        timeMax: endDate.toISOString(),
                        showDeleted: String(showDeleted)
                    });
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events?${params.toString()}`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data.items || [];
                },
                async getEvents(day) {
                    const params = new URLSearchParams({ singleEvents: 'true', orderBy: 'startTime', maxResults: '2500' });
                    if (day === 'all') {
                        params.append('q', '" - Sedinta "');
                    } else {
                        const targetDate = new Date();
                        if (day === 'tomorrow') targetDate.setDate(targetDate.getDate() + 1);
                        const startOfDay = new Date(targetDate);
                        startOfDay.setHours(0, 0, 0, 0);
                        params.append('timeMin', startOfDay.toISOString());
                        const endOfDay = new Date(targetDate);
                        endOfDay.setHours(23, 59, 59, 999);
                        params.append('timeMax', endOfDay.toISOString());
                    }
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events?${params.toString()}`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return await processCalendarItems(data.items);
                },
                async searchEvents(query) {
                    const params = new URLSearchParams({ q: `${query} " - Sedinta "`, singleEvents: 'true', orderBy: 'startTime', maxResults: '2500' });
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events?${params.toString()}`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return await processCalendarItems(data.items);
                },
                async findLastPastEvent(clientName) {
                    const now = new Date();
                    now.setHours(0, 0, 0, 0); // Start of today
                    const thirtyDaysAgo = new Date();
                    thirtyDaysAgo.setDate(now.getDate() - 30);

                    const params = new URLSearchParams({
                        q: `"${clientName}"`,
                        singleEvents: 'true',
                        orderBy: 'startTime',
                        timeMax: now.toISOString(),
                        timeMin: thirtyDaysAgo.toISOString(),
                        maxResults: '250'
                    });

                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events?${params.toString()}`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);

                    const sortedEvents = (data.items || [])
                        .filter(event => {
                            if (!event.summary || event.status === 'cancelled') return false;
                            const parts = event.summary.split(' - ').map(p => p.trim());
                            if (parts.length < 3 || parts[0] !== clientName || !parts[2].toLowerCase().includes('sedinta')) {
                                return false;
                            }
                            const sessionPart = parts[2];
                            const parsedNumber = parseInt(sessionPart.toLowerCase().replace('sedinta', '').replace('#', ''), 10);
                            return !isNaN(parsedNumber); // Only keep events where a number can be parsed
                        })
                        .sort((a, b) => new Date(b.start.dateTime || b.start.date) - new Date(a.start.dateTime || a.start.date));

                    return sortedEvents.length > 0 ? sortedEvents[0] : null;
                },
                async fetchHistory(clientName) {
                    const sixtyDaysAgo = new Date();
                    sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events?timeMin=${sixtyDaysAgo.toISOString()}&timeMax=${new Date().toISOString()}&q=${encodeURIComponent(`${clientName} - `)}&singleEvents=true&orderBy=startTime&showDeleted=true`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);

                    const allEvents = (data.items || [])
                        .map(event => {
                            const organizer = event.attendees?.find(a => a.organizer);
                            const isDeclinedByOrganizer = organizer?.responseStatus === 'declined';
                            return { id: event.id, date: event.start?.dateTime || event.start?.date, summary: event.summary, isDeclinedByOrganizer, status: event.status };
                        })
                        .filter(event => event.summary && event.date);

                    const confirmedEvents = allEvents.filter(e => !e.isDeclinedByOrganizer && e.status === 'confirmed');
                    const cancelledEvents = allEvents.filter(e => e.isDeclinedByOrganizer);

                    const processedCancelledEvents = cancelledEvents.map(cancelledEvent => {
                        const correspondingConfirmed = confirmedEvents.find(confirmedEvent =>
                            confirmedEvent.summary === cancelledEvent.summary &&
                            new Date(confirmedEvent.date) > new Date(cancelledEvent.date)
                        );
                        return { ...cancelledEvent, status: correspondingConfirmed ? 'rescheduled' : 'cancelled', rescheduledTo: correspondingConfirmed?.date };
                    });

                    const finalHistory = [...confirmedEvents, ...processedCancelledEvents].sort((a, b) => new Date(b.date) - new Date(a.date));

                    return finalHistory.reduce((acc, session) => {
                        const monthYear = new Date(session.date).toLocaleString('ro-RO', { month: 'long', year: 'numeric' });
                        const capitalized = monthYear.charAt(0).toUpperCase() + monthYear.slice(1);
                        if (!acc[capitalized]) acc[capitalized] = [];
                        acc[capitalized].push(session);
                        return acc;
                    }, {});
                },
                async cancelEvent(eventId) {
                    const getUrl = `https://www.googleapis.com/calendar/v3/calendars/${state.calendarId}/events/${eventId}`;
                    const getResponse = await fetch(getUrl, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const eventData = await getResponse.json();
                    if (eventData.error) throw new Error(`Failed to get event details: ${eventData.error.message}`);

                    const organizerEmail = eventData.organizer?.email;
                    if (!organizerEmail) throw new Error("Could not identify the event organizer.");
                    if (!eventData.attendees) throw new Error("Event has no attendees list to modify.");

                    const updatedAttendees = eventData.attendees.map(attendee =>
                        attendee.email === organizerEmail ? { ...attendee, responseStatus: 'declined' } : attendee
                    );

                    const patchUrl = `https://www.googleapis.com/calendar/v3/calendars/${state.calendarId}/events/${eventId}`;
                    const patchResponse = await fetch(patchUrl, {
                        method: 'PATCH',
                        headers: { 'Authorization': `Bearer ${state.accessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ attendees: updatedAttendees })
                    });
                    const patchData = await patchResponse.json();
                    if (patchData.error) throw new Error(`Failed to update event: ${patchData.error.message}`);
                    return patchData;
                },
                async fetchCourses() {
                    const response = await fetch('https://classroom.googleapis.com/v1/courses', { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data.courses || [];
                },
                async postHomework({ courseId, studentEmail, discipline, homework }) {
                    const title = `Temă (${new Date().toLocaleDateString('ro-RO')}) - ${discipline}`;
                    const url = `https://classroom.googleapis.com/v1/courses/${courseId}/courseWork`;
                    const body = { title, description: homework, workType: 'ASSIGNMENT', state: 'PUBLISHED', assigneeMode: 'INDIVIDUAL_STUDENTS', individualStudentsOptions: { studentIds: [studentEmail] } };
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${state.accessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data;
                },
                async getEventById(eventId) {
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events/${eventId}`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data;
                },
                async updateEventDescription(eventId, newDescription) {
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${state.calendarId}/events/${eventId}`;
                    const body = { description: newDescription };
                    const response = await fetch(url, {
                        method: 'PATCH',
                        headers: { 'Authorization': `Bearer ${state.accessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data;
                },
                async updateEventSummary(eventId, newSummary, colorId = null) {
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${state.calendarId}/events/${eventId}`;
                    const body = { summary: newSummary, ...(colorId && { colorId }) };
                    const response = await fetch(url, {
                        method: 'PATCH',
                        headers: { 'Authorization': `Bearer ${state.accessToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                    return data;
                },
                async createEvent(eventData) {
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${state.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(eventData)
                    });
                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error.message);
                    }
                    return data;
                },
                async getUpcomingEvents(clientName) {
                    const timeMin = new Date().toISOString();
                    const timeMax = new Date(new Date().setDate(new Date().getDate() + 30)).toISOString();

                    const params = new URLSearchParams({
                        q: `"${clientName}"`,
                        singleEvents: 'true',
                        orderBy: 'startTime',
                        timeMin: timeMin,
                        timeMax: timeMax,
                        maxResults: '50'
                    });
                    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(state.calendarId)}/events?${params.toString()}`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${state.accessToken}` } });
                    const data = await response.json();
                    if (data.error) throw new Error(data.error.message);

                    return (data.items || []).filter(event => {
                        if (event.status === 'cancelled') return false;
                        const isDeclinedByOrganizer = event.attendees?.find(a => a.organizer)?.responseStatus === 'declined';
                        return !isDeclinedByOrganizer;
                    });
                },
            };

            // --- RENDER & UI FUNCTIONS ---
            const renderNotification = (message, type = 'success') => {
                const colors = {
                    error: { bg: 'bg-red-900/50', border: 'border-red-700', text: 'text-red-300', icon: 'shield-alert' },
                    success: { bg: 'bg-green-900/50', border: 'border-green-700', text: 'text-green-300', icon: 'info' },
                };
                const selected = colors[type];
                dom.notificationArea.innerHTML = `
                    <div class="fade-in ${selected.bg} border-l-4 ${selected.border} ${selected.text} p-4 rounded-md shadow-md relative" role="alert">
                        <div class="flex">
                            <div class="py-1"><i data-lucide="${selected.icon}" class="h-6 w-6 mr-4"></i></div>
                            <div>
                                <p class="font-bold">${type.charAt(0).toUpperCase() + type.slice(1)}</p>
                                <p class="text-sm">${message}</p>
                            </div>
                        </div>
                        <button onclick="document.getElementById('notification-area').innerHTML = ''" class="absolute top-2 right-2 text-gray-400 hover:text-white">
                            <i data-lucide="x-circle" class="h-5 w-5"></i>
                        </button>
                    </div>
                `;
                lucide.createIcons();
            };

            const renderLoader = (message) => {
                dom.resultsArea.innerHTML = `<div class="flex items-center justify-center p-10"><i data-lucide="loader-2" class="h-8 w-8 animate-spin text-blue-400"></i><span class="ml-3 text-lg">${message}</span></div>`;
                lucide.createIcons();
            };

            const populateDisciplineFilter = (clients) => {
                const disciplines = [...new Set(Object.values(clients).map(client => client.discipline))].sort();
                dom.disciplineFilter.innerHTML = `<option value="all">Toate Disciplinele</option>`;
                disciplines.forEach(discipline => {
                    const option = document.createElement('option');
                    option.value = discipline;
                    option.textContent = discipline;
                    dom.disciplineFilter.appendChild(option);
                });
                dom.disciplineFilter.value = state.activeDiscipline;
            };

            const renderClients = (allClients, clientFirebaseData) => {
                state.fetched = true;
                let clientEntries = Object.entries(allClients);

                if (state.activeDiscipline !== 'all') {
                    clientEntries = clientEntries.filter(([_, details]) => details.discipline === state.activeDiscipline);
                }
                if (state.filterLastSessionOnly) {
                    clientEntries = clientEntries.filter(([name, details]) => {
                        const subType = clientFirebaseData[name]?.subscription || '4';
                        return details.sessionNumber === parseInt(subType);
                    });
                }

                if (state.activeTab === 'today' || state.activeTab === 'tomorrow') {
                    clientEntries.sort(([, a], [, b]) => new Date(a.startTime) - new Date(b.startTime));
                } else {
                    clientEntries.sort(([nameA], [nameB]) => nameA.localeCompare(nameB));
                }

                if (clientEntries.length === 0) {
                    const tabTitle = { today: 'astăzi', tomorrow: 'mâine', all: 'toți clienții' }[state.activeTab];
                    let message = state.searchQuery ? `Niciun client găsit pentru "${state.searchQuery}".` : `Nu s-au găsit programări pentru ${tabTitle}.`;
                    if (state.activeDiscipline !== 'all') message = `Nu s-au găsit programări pentru ${state.activeDiscipline} in ${tabTitle}.`;
                    if (state.filterLastSessionOnly) message += ` Afișând doar clienții în ultima ședință.`
                    dom.resultsArea.innerHTML = `<div class="text-center py-12"><p class="text-lg text-gray-400">${message}</p></div>`;
                    return;
                }

                const displayTitle = getDisplayTitle();
                const clientListHTML = clientEntries.map(([name, details]) => createClientListItemHTML(name, details, clientFirebaseData[name])).join('');

                dom.resultsArea.innerHTML = `
                    <div class="bg-gray-800 shadow-xl rounded-2xl overflow-hidden fade-in">
                        <div class="px-6 py-4 bg-gray-700 border-b border-gray-600">
                            <h2 class="text-2xl font-bold text-gray-200">${displayTitle}</h2>
                        </div>
                        <ul class="divide-y divide-gray-600">${clientListHTML}</ul>
                    </div>
                `;
                lucide.createIcons();
                attachClientEventListeners();
            };

            const createClientListItemHTML = (name, details, clientData) => {
                const { eventId, discipline, sessionNumber, phone, startTime, lastPayment } = details;
                const subscriptionType = clientData?.subscription || '4';
                const assignedInstructor = clientData?.assignedInstructor || '';
                const isExpanded = state.expandedClient === name;
                const formattedTime = startTime ? new Date(startTime).toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' }) : '';
                const formattedDate = startTime ? new Date(startTime).toLocaleDateString('ro-RO', { weekday: 'long', day: 'numeric', month: 'long' }) : (state.activeTab === 'today' ? 'astăzi' : 'mâine');

                const messageData = { name, discipline, date: formattedDate, time: formattedTime };
                const notificationMessage = replacePlaceholders(state.messageTemplates.notification, messageData);
                const lastSessionMessage = replacePlaceholders(state.messageTemplates.lastSession, messageData);
                const newSubMessage = replacePlaceholders(state.messageTemplates.newSubscription, messageData);

                const instructorOptions = state.instructors.map(inst => `<option value="${inst.name}" ${assignedInstructor === inst.name ? 'selected' : ''}>${inst.name}</option>`).join('');

                const eventIdentifier = btoa(`${eventId} ${state.calendarId}`).replace(/=/g, '');
                const editUrl = `https://calendar.google.com/calendar/r/eventedit/${eventIdentifier}`;

                return `
                <li id="client-${eventId}" class="px-6 py-5 hover:bg-gray-700/50 transition-colors duration-200">
                        <div class="flex items-center justify-between flex-wrap cursor-pointer client-header" data-name="${name}">
                            <div class="flex-grow mb-4 md:mb-0">
                                <div class="flex items-center">
                                    <span class="text-2xl font-semibold text-gray-100 bg-gray-600 px-3 py-1 rounded-lg">${name}</span>
                                    ${(state.activeTab === 'today' || state.activeTab === 'tomorrow') ?
                        `<a href="${editUrl}" target="_blank" class="ml-3 p-2 rounded-md bg-yellow-500 text-white hover:bg-yellow-600" title="Editează Eveniment în Google Calendar">
                                        <i data-lucide="calendar-days" class="h-4 w-4"></i>
                                    </a>` : ''
                    }
                                    <span class="chevron-icon-wrapper inline-block transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}">
                                        <i data-lucide="chevron-down" class="h-5 w-5 ml-2 text-gray-400"></i>
                                    </span>
                                </div>
                                <p class="text-sm text-gray-400 mt-2">${discipline}</p>
                                <div class="mt-2 flex flex-wrap items-center gap-2">
                                    <select class="subscription-select w-full max-w-[200px] text-sm px-2 py-1 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" data-name="${name}">
                                        <option value="4" ${subscriptionType === '4' ? 'selected' : ''}>Abonament de 4 sedinte</option>
                                        <option value="8" ${subscriptionType === '8' ? 'selected' : ''}>Abonament de 8 sedinte</option>
                                    </select>
                                    <select class="instructor-select w-full max-w-[200px] text-sm px-2 py-1 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" data-name="${name}">
                                        <option value="">Nealocat</option>
                                        ${instructorOptions}
                                    </select>
                                    <span class="sub-status text-xs text-green-400 opacity-0">Salvat!</span>
                                </div>
                                ${(state.activeTab === 'today' || state.activeTab === 'tomorrow') && startTime ? `<div class="flex items-center mt-1 text-sm text-blue-400 font-semibold"><i data-lucide="clock" class="h-4 w-4 mr-2"></i><span>${formattedTime}</span></div>` : ''}
                                <div class="flex items-center gap-2 mt-2">
                                    ${phone ? `<button class="whatsapp-btn flex items-center justify-center bg-green-500 text-white font-bold py-1.5 px-3 rounded-lg hover:bg-green-600 text-xs" data-phone="${phone}"><svg role="img" viewBox="0 0 24 24" class="h-4 w-4 mr-2" fill="currentColor"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.297-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52s-.67-.816-.916-1.103c-.247-.287-.5-.318-.67-.323-.172-.005-.371-.005-.57-.005-.198 0-.52.074-.792.372s-1.04 1.016-1.04 2.479 1.065 2.876 1.213 3.074c.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871-.118.571-.355 1.758-2.16 2.03-2.874.272-.714.272-1.319.198-1.469-.074-.15-.272-.222-.57-.371z"/></svg><span>${phone}</span></button>` : ''}
                                    <button class="log-cash-btn flex items-center justify-center bg-emerald-500 text-white font-bold py-1.5 px-3 rounded-lg hover:bg-emerald-600 disabled:bg-gray-400 text-xs" data-name="${name}" data-event-id="${eventId}" ${state.activeTab !== 'today' && state.activeTab !== 'tomorrow' ? 'disabled' : ''}>
                                        <i data-lucide="dollar-sign" class="h-4 w-4 mr-1.5"></i><span>Cash</span>
                                    </button>
                                </div>
                                ${lastPayment ? `<div class="flex items-center mt-1 text-sm ${isPaymentOverdue(lastPayment) ? 'text-red-400 font-semibold' : 'text-gray-300'}"><i data-lucide="dollar-sign" class="h-4 w-4 mr-2"></i><span>Ultima Plată: ${lastPayment}</span></div>` : ''}
                            </div>
                            <div class="flex flex-col items-end space-y-2 w-full sm:w-48">
                                <div class="w-full text-right mb-2">
                                    <span class="text-xs font-medium text-gray-300">Sedinta ${sessionNumber} / ${subscriptionType}</span>
                                    <div class="mt-1 w-full bg-gray-700 rounded-full h-2.5"><div class="bg-blue-600 h-2.5 rounded-full" style="width: ${Math.min((sessionNumber / parseInt(subscriptionType)) * 100, 100)}%"></div></div>
                                </div>
                                <button class="whatsapp-btn w-full flex items-center justify-center bg-green-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-green-600 disabled:bg-gray-400 text-xs" data-phone="${phone}" data-message="${notificationMessage}" ${!phone || !startTime || state.activeTab === 'all' ? 'disabled' : ''}><i data-lucide="message-square" class="h-4 w-4 mr-1.5"></i><span>Notificare sedinta</span></button>
                                <button class="whatsapp-btn w-full flex items-center justify-center bg-orange-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-orange-600 disabled:bg-gray-400 text-xs" data-phone="${phone}" data-message="${lastSessionMessage}" ${sessionNumber !== parseInt(subscriptionType) || !phone || state.activeTab === 'all' ? 'disabled' : ''}><i data-lucide="credit-card" class="h-4 w-4 mr-1.5"></i><span>Notificare ultima sedinta</span></button>
                                <button class="whatsapp-btn w-full flex items-center justify-center bg-teal-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-teal-600 disabled:bg-gray-400 text-xs" data-phone="${phone}" data-message="${newSubMessage}" ${sessionNumber !== 1 || !phone || state.activeTab === 'all' ? 'disabled' : ''}><i data-lucide="refresh-cw" class="h-4 w-4 mr-1.5"></i><span>Notificare plată nouă</span></button>
                                <button class="decline-btn w-full flex items-center justify-center bg-red-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-red-600 disabled:bg-gray-400 text-xs" data-event-id="${eventId}" data-name="${name}" data-discipline="${discipline}" data-phone="${phone}" ${state.activeTab !== 'today' && state.activeTab !== 'tomorrow' ? 'disabled' : ''}><i data-lucide="x-circle" class="h-4 w-4 mr-1.5"></i><span>Anulează</span></button>
                                <button class="increment-session-btn w-full flex items-center justify-center bg-blue-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-blue-600 disabled:bg-gray-400 text-xs" data-event-id="${eventId}" data-name="${name}" ${state.activeTab !== 'today' && state.activeTab !== 'tomorrow' ? 'disabled' : ''}>
                                    <i data-lucide="plus-circle" class="h-4 w-4 mr-1.5"></i><span>Incrementeaza sedinta</span>
                                </button>
                            </div>
                        </div>
                        <div class="client-details w-full" style="display: ${isExpanded ? 'block' : 'none'};">
                            </div>
                    </li>
                `;
            };

            const createHomeworkHTML = (name, client) => {
                if (!client) return '';
                if (!state.courses) return `<p>Se încarcă cursurile...</p>`;
                if (state.courses.length === 0) return `<p class="text-red-500">Nu s-au găsit cursuri Google Classroom.</p>`;

                const courseOptions = state.courses.map(c => `<option value="${c.id}">${c.name}</option>`).join('');

                return `
                    <div class="mb-4 homework-form" data-name="${name}" data-discipline="${client.discipline}" data-session-number="${client.sessionNumber}">
                        <h4 class="text-md font-semibold text-gray-200 mb-2">Temă pentru Acasă</h4>
                        <div class="flex items-center space-x-2 mb-2">
                            <label class="text-sm font-medium">Curs:</label>
                            <select class="course-select block w-full rounded-md border-gray-600 bg-gray-700 shadow-sm sm:text-sm">${courseOptions}</select>
                        </div>
                        <textarea rows="4" class="homework-text w-full p-2 border border-gray-600 bg-gray-700 rounded-md" placeholder="Scrie tema aici..."></textarea>
                        <button class="post-homework-btn mt-2 flex items-center justify-center bg-blue-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-blue-600 disabled:bg-gray-400 text-xs" data-discipline="${client.discipline}" data-student-email="${client.studentEmail || ''}" ${!client.studentEmail ? 'disabled' : ''}>
                            <i data-lucide="book" class="h-4 w-4 mr-1.5"></i><span>Postează Tema</span>
                        </button>
                        ${!client.studentEmail ? `<p class="text-xs text-red-500 mt-1">Nu s-a găsit e-mailul studentului.</p>` : ''}
                    </div>
                `;
            };

            const createNotesHTML = (clientName, notes) => {
                return `
                    <div class="notes-section" data-client-name="${clientName}">
                        <div class="flex justify-between items-center mb-2">
                             <h4 class="text-md font-semibold text-gray-200">Notițe</h4>
                             <span class="notes-status text-xs text-gray-500 opacity-0">Se salvează...</span>
                        </div>
                        <textarea class="notes-textarea w-full p-2 border border-gray-600 bg-gray-700 rounded-md" rows="4" placeholder="Adaugă notițe permanente pentru acest client...">${notes}</textarea>
                    </div>
                `;
            };

            const createHistoryHTML = (history) => {
                if (Object.keys(history).length === 0) return `<p class="text-sm text-gray-400">Nu s-au găsit ședințe în ultimele 60 de zile.</p>`;
                return `<ul class="space-y-2">` + Object.entries(history).map(([monthYear, sessions]) => `
                    <li>
                        <div class="history-month-header flex items-center justify-between p-2 bg-gray-700 hover:bg-gray-600 rounded-md cursor-pointer">
                            <span class="font-semibold text-gray-100">${monthYear}</span>
                            <span class="history-chevron-wrapper inline-block transition-transform duration-300">
                                <i data-lucide="chevron-down" class="h-5 w-5 text-gray-400"></i>
                            </span>
                        </div>
                        <ul class="history-month-list mt-2 pl-4 space-y-1" style="display: none;">
                            ${sessions.map(s => {
                    const date = new Date(s.date);
                    if (isNaN(date.getTime())) return '';
                    const statusClass = s.status === 'cancelled' ? 'bg-red-900/50 text-red-300' : s.status === 'rescheduled' ? 'bg-yellow-900/50 text-yellow-300' : 'bg-gray-600/50 text-gray-300';
                    const rescheduledDate = s.rescheduledTo ? new Date(s.rescheduledTo) : null;
                    const rescheduledText = rescheduledDate && !isNaN(rescheduledDate.getTime())
                        ? `(Reprogramat pentru ${rescheduledDate.toLocaleDateString('ro-RO', { day: 'numeric', month: 'long' })})`
                        : '';
                    const statusText = s.status === 'cancelled' ? '(Anulat)' : s.status === 'rescheduled' ? rescheduledText : '';
                    return `<li class="text-sm p-2 rounded-md ${statusClass}">${s.summary} <span class="font-semibold ml-2">${statusText}</span></li>`;
                }).join('')}
                        </ul>
                    </li>
                `).join('') + `</ul>`;
            };

            const getDisplayTitle = () => {
                if (state.searchQuery) return 'Rezultate Căutare';
                const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                if (state.activeTab === 'today') return `Sumar Clienți pentru Astăzi (${new Date().toLocaleDateString('ro-RO', options)})`;
                if (state.activeTab === 'tomorrow') {
                    const tomorrow = new Date();
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    return `Sumar Clienți pentru Mâine (${tomorrow.toLocaleDateString('ro-RO', options)})`;
                }
                if (state.activeTab === 'instructors') return 'Gestionează Instructorii';
                if (state.activeTab === 'financials') return 'Date Financiare';
                if (state.activeTab === 'reports') return 'Rapoarte Avansate';
                if (state.activeTab === 'settings') return 'Setări Aplicație';
                if (state.activeTab === 'dashboard') return 'Dashboard';
                if (state.activeTab === 'add') return 'Adaugă Programare Nouă';
                return 'Sumar Toți Clienții';
            };

            // REPLACED FUNCTION: renderInstructorsView
            const renderInstructorsView = () => {
                dom.resultsArea.innerHTML = `
                <div class="bg-gray-800 shadow-xl rounded-2xl overflow-hidden fade-in">
                    <div class="px-6 py-4 bg-gray-700 border-b border-gray-600">
                       <h2 class="text-2xl font-bold text-gray-200">Gestionează Instructorii</h2>
                    </div>
                    <div class="p-6 space-y-4">
                        <div class="flex flex-col sm:flex-row gap-2">
                            <input type="text" id="newInstructorName" placeholder="Nume instructor nou" class="flex-grow px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <input type="text" id="newInstructorPhone" placeholder="Telefon (ex: +407...)" class="flex-grow px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="addInstructorBtn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="h-5 w-5"></i>
                            </button>
                        </div>
                        <ul id="instructorList" class="divide-y divide-gray-600">
                            </ul>
                    </div>
                </div>
                `;
                lucide.createIcons();
                attachInstructorEventListeners();

                const list = document.getElementById('instructorList');
                if (!list) return;
                list.innerHTML = state.instructors.map(inst => `
        <li class="flex flex-wrap items-center justify-between py-3 gap-4">
            <span class="text-gray-300 font-semibold min-w-[120px]">${inst.name}</span>
            <div class="flex-1 flex items-center gap-2 min-w-[250px]">
                <input type="text" value="${inst.phone || ''}" placeholder="Telefon" data-id="${inst.id}" class="instructor-phone-input w-full px-3 py-1 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                <div class="relative w-28">
                     <input type="number" value="${state.instructorPercentages[inst.id] || ''}" placeholder="Procentaj" data-id="${inst.id}" class="instructor-percentage-input w-full px-3 py-1 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                     <div class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                        <span class="text-gray-400 text-sm">%</span>
                     </div>
                </div>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
                <button class="notify-instructor-btn bg-cyan-600 text-white p-2 rounded-md hover:bg-cyan-700" data-id="${inst.id}" data-name="${inst.name}" data-phone="${inst.phone || ''}" title="Notifică pentru programul de mâine">
                    <i data-lucide="send" class="h-4 w-4"></i>
                </button>
                <button class="delete-instructor-btn text-red-500 hover:text-red-400 p-2" data-id="${inst.id}">
                    <i data-lucide="trash-2" class="h-4 w-4"></i>
                </button>
            </div>
        </li>
    `).join('');
                lucide.createIcons();
                attachInstructorDeleteListeners();
                attachInstructorPhoneInputListeners();
                attachInstructorNotifyListeners();
                attachInstructorPercentageListeners(); // NEW call
            };

            const renderSettingsView = () => {
                const settingsHTML = `
                    <div class="bg-gray-800 shadow-xl rounded-2xl overflow-hidden fade-in">
                        <div class="px-6 py-4 bg-gray-700 border-b border-gray-600">
                            <h2 class="text-2xl font-bold text-gray-200">Setări Aplicație</h2>
                        </div>
                        <div class="p-6 space-y-6">
                            ${createApiKeysSettingsHTML()}
                            ${createMessageSettingsHTML()}
                            ${createDoubleBookingSettingsHTML()}
                            ${createWorkingHoursSettingsHTML()}
                        </div>
                    </div>
                `;
                dom.resultsArea.innerHTML = settingsHTML;
                lucide.createIcons();
                attachSettingsEventListeners();
            };

            const createApiKeysSettingsHTML = () => {
                const isExpanded = state.isApiKeysExpanded;
                return `
                    <div class="border border-gray-700 rounded-lg">
                        <button id="toggle-api-keys-btn" class="w-full flex justify-between items-center p-4 bg-gray-700/50 hover:bg-gray-700 ${isExpanded ? 'rounded-t-lg' : 'rounded-lg'} focus:outline-none">
                            <span class="text-lg font-semibold text-gray-200">Chei API (Integrări)</span>
                            <span class="settings-chevron-wrapper inline-block transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}">
                                <i data-lucide="chevron-down" class="h-6 w-6 text-gray-400"></i>
                            </span>
                        </button>
                        <div id="api-keys-container" class="p-6 space-y-6 border-t border-gray-700" style="display: ${isExpanded ? 'block' : 'none'};">
                            <div>
                                <label for="stripe-key-input" class="block text-sm font-medium text-gray-300 mb-1">Cheie Restricționată Stripe</label>
                                <div class="flex items-center gap-2">
                                    <input type="password" id="stripe-key-input" placeholder="rk_live_..." class="flex-grow px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <button id="save-stripe-key-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Salvează</button>
                                </div>
                                <div class="mt-2 p-3 rounded-md bg-yellow-900/50 border border-yellow-700 text-yellow-300 text-xs">
                                    <div class="flex items-start">
                                        <i data-lucide="shield-alert" class="h-4 w-4 mr-2 mt-0.5 flex-shrink-0"></i>
                                        <span>
                                            <span class="font-bold">Atenție:</span> Salvați această cheie aici doar pentru a fi utilizată de un dezvoltator pentru a construi o integrare de backend sigură (ex: Firebase Cloud Function). Nu utilizați această cheie direct în aplicație pentru a prelua date, deoarece ar expune-o public.
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            };

            const createMessageSettingsHTML = () => {
                const isExpanded = state.isSettingsExpanded;
                return `
                    <div class="border border-gray-700 rounded-lg">
                        <button id="toggle-messages-btn" class="w-full flex justify-between items-center p-4 bg-gray-700/50 hover:bg-gray-700 ${isExpanded ? 'rounded-t-lg' : 'rounded-lg'} focus:outline-none">
                            <span class="text-lg font-semibold text-gray-200">Modifică Mesaje WhatsApp</span>
                            <span class="settings-chevron-wrapper inline-block transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}">
                                <i data-lucide="chevron-down" class="h-6 w-6 text-gray-400"></i>
                            </span>
                        </button>
                        <div id="messages-container" class="p-6 space-y-6 border-t border-gray-700" style="display: ${isExpanded ? 'block' : 'none'};">
                            ${createMessageTemplateEditorHTML('notification', 'Notificare Ședință', state.messageTemplates.notification)}
                            ${createMessageTemplateEditorHTML('lastSession', 'Notificare Ultima Ședință', state.messageTemplates.lastSession)}
                            ${createMessageTemplateEditorHTML('newSubscription', 'Notificare Plată Nouă', state.messageTemplates.newSubscription)}
                            ${createMessageTemplateEditorHTML('cancelByInstructor', 'Anulare de către Instructor', state.messageTemplates.cancelByInstructor)}
                            ${createMessageTemplateEditorHTML('cancelByClient', 'Anulare de către Client', state.messageTemplates.cancelByClient)}
                            <div class="flex justify-end pt-4">
                                <button id="save-messages-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors">
                                    Salvează Mesajele
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            const createDoubleBookingSettingsHTML = () => {
                const isExpanded = state.isDoubleBookingExpanded;
                const days = { 'Luni': 1, 'Marți': 2, 'Miercuri': 3, 'Joi': 4, 'Vineri': 5, 'Sâmbătă': 6 };
                let daysHTML = Object.keys(days).map(dayName => {
                    const rule = state.doubleBookingRules[dayName] || { enabled: false, startTime: 14, endTime: 21 };
                    return `
                        <div class="flex items-center space-x-4 p-2 rounded-md hover:bg-gray-700/50">
                            <label class="flex items-center space-x-2 w-32 cursor-pointer">
                                <input type="checkbox" data-day="${dayName}" class="day-enable-checkbox h-4 w-4 rounded border-gray-500 bg-gray-700 text-blue-600 focus:ring-blue-500" ${rule.enabled ? 'checked' : ''}>
                                <span class="font-medium text-gray-300">${dayName}</span>
                            </label>
                            <div class="flex items-center space-x-2">
                                <input type="number" min="9" max="21" value="${rule.startTime}" data-day="${dayName}" data-type="start" class="time-input w-20 px-2 py-1 border border-gray-600 bg-gray-800 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" ${!rule.enabled ? 'disabled' : ''}>
                                <span>-</span>
                                <input type="number" min="9" max="21" value="${rule.endTime}" data-day="${dayName}" data-type="end" class="time-input w-20 px-2 py-1 border border-gray-600 bg-gray-800 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" ${!rule.enabled ? 'disabled' : ''}>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                     <div class="border border-gray-700 rounded-lg">
                         <button id="toggle-double-booking-btn" class="w-full flex justify-between items-center p-4 bg-gray-700/50 hover:bg-gray-700 ${isExpanded ? 'rounded-t-lg' : 'rounded-lg'} focus:outline-none">
                             <span class="text-lg font-semibold text-gray-200">Reguli de Rezervare Dublă</span>
                             <span class="settings-chevron-wrapper inline-block transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}">
                                 <i data-lucide="chevron-down" class="h-6 w-6 text-gray-400"></i>
                             </span>
                         </button>
                         <div id="double-booking-container" class="p-6 space-y-4 border-t border-gray-700" style="display: ${isExpanded ? 'block' : 'none'};">
                             <p class="text-sm text-gray-400">Selectează zilele și intervalele orare în care sunt permise două programări pe oră.</p>
                             ${daysHTML}
                             <div class="flex justify-end pt-4">
                                 <button id="save-booking-rules-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors">
                                     Salvează Regulile
                                 </button>
                             </div>
                         </div>
                     </div>
                `;
            };

            const createWorkingHoursSettingsHTML = () => {
                const isExpanded = state.isWorkingHoursExpanded;
                const days = ['Luni', 'Marți', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'];
                let daysHTML = days.map(dayName => {
                    const hours = state.workingHours[dayName] || { enabled: true, startTime: 9, endTime: 21 };
                    return `
                        <div class="flex items-center space-x-4 p-2 rounded-md hover:bg-gray-700/50">
                            <label class="flex items-center space-x-2 w-32 cursor-pointer">
                                <input type="checkbox" data-day="${dayName}" class="wh-day-enable-checkbox h-4 w-4 rounded border-gray-500 bg-gray-700 text-blue-600 focus:ring-blue-500" ${hours.enabled ? 'checked' : ''}>
                                <span class="font-medium text-gray-300">${dayName}</span>
                            </label>
                            <div class="flex items-center space-x-2">
                                <input type="number" min="0" max="23" value="${hours.startTime}" data-day="${dayName}" data-type="start" class="wh-time-input w-20 px-2 py-1 border border-gray-600 bg-gray-800 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" ${!hours.enabled ? 'disabled' : ''}>
                                <span>-</span>
                                <input type="number" min="1" max="24" value="${hours.endTime}" data-day="${dayName}" data-type="end" class="wh-time-input w-20 px-2 py-1 border border-gray-600 bg-gray-800 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" ${!hours.enabled ? 'disabled' : ''}>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                     <div class="border border-gray-700 rounded-lg">
                         <button id="toggle-working-hours-btn" class="w-full flex justify-between items-center p-4 bg-gray-700/50 hover:bg-gray-700 ${isExpanded ? 'rounded-t-lg' : 'rounded-lg'} focus:outline-none">
                             <span class="text-lg font-semibold text-gray-200">Setări Program de Lucru</span>
                             <span class="settings-chevron-wrapper inline-block transition-transform duration-300 ${isExpanded ? 'rotate-180' : ''}">
                                 <i data-lucide="chevron-down" class="h-6 w-6 text-gray-400"></i>
                             </span>
                         </button>
                         <div id="working-hours-container" class="p-6 space-y-4 border-t border-gray-700" style="display: ${isExpanded ? 'block' : 'none'};">
                             <p class="text-sm text-gray-400">Definește programul de lucru pentru fiecare zi. Zilele nebifate nu vor afișa intervale disponibile.</p>
                             ${daysHTML}
                             <div class="flex justify-end pt-4">
                                 <button id="save-working-hours-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-colors">
                                     Salvează Programul
                                 </button>
                             </div>
                         </div>
                     </div>
                `;
            };

            const createMessageTemplateEditorHTML = (id, label, value) => {
                return `
                    <div>
                        <label for="template-${id}" class="block text-sm font-medium text-gray-300 mb-2">${label}</label>
                        <div class="flex items-center gap-2 mb-2 flex-wrap">
                            <span class="text-xs text-gray-400">Variabile:</span>
                            <button class="variable-btn text-xs bg-gray-600 hover:bg-gray-500 text-gray-200 px-2 py-1 rounded" data-target="template-${id}" data-value="{Nume}">{Nume}</button>
                            <button class="variable-btn text-xs bg-gray-600 hover:bg-gray-500 text-gray-200 px-2 py-1 rounded" data-target="template-${id}" data-value="{Data}">{Data}</button>
                            <button class="variable-btn text-xs bg-gray-600 hover:bg-gray-500 text-gray-200 px-2 py-1 rounded" data-target="template-${id}" data-value="{Ora}">{Ora}</button>
                            <button class="variable-btn text-xs bg-gray-600 hover:bg-gray-500 text-gray-200 px-2 py-1 rounded" data-target="template-${id}" data-value="{Disciplina}">{Disciplina}</button>
                        </div>
                        <textarea id="template-${id}" class="w-full p-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" rows="4">${value}</textarea>
                    </div>
                `;
            };

            const renderDashboard = (dashboardData) => {
                const { totalStudents, sessionsThisWeek, endingSubscriptions, disciplineBreakdown, dateRangeString } = dashboardData;

                // Create Discipline Breakdown Chart
                const maxCount = Math.max(1, ...Object.values(disciplineBreakdown)); // Avoid division by zero
                const disciplineChartHTML = Object.entries(disciplineBreakdown).map(([discipline, count]) => `
                    <div class="flex items-center text-sm">
                        <span class="w-24 truncate" title="${discipline}">${discipline}</span>
                        <div class="flex-1 bg-gray-700 rounded-full h-4 mx-2">
                            <div class="bg-blue-600 h-4 rounded-full text-xs text-white flex items-center justify-center" style="width: ${(count / maxCount) * 100}%">
                                <span>${count}</span>
                            </div>
                        </div>
                    </div>
                `).join('');

                const dashboardHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 fade-in">
                        <div class="space-y-6">
                            <div class="bg-gray-800 p-6 rounded-xl shadow-lg flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium text-gray-400">Total Studenți Activi</p>
                                    <p class="text-4xl font-bold text-white">${totalStudents}</p>
                                </div>
                                <div class="bg-purple-500/20 p-3 rounded-full">
                                    <i data-lucide="users" class="h-8 w-8 text-purple-400"></i>
                                </div>
                            </div>

                            <div class="bg-gray-800 p-6 rounded-xl shadow-lg flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium text-gray-400">Ședințe Săptămâna Aceasta</p>
                                    <p class="text-xs text-gray-500">${dateRangeString}</p>
                                    <p class="text-4xl font-bold text-white mt-1">${sessionsThisWeek}</p>
                                </div>
                                <div class="bg-green-500/20 p-3 rounded-full">
                                    <i data-lucide="calendar" class="h-8 w-8 text-green-400"></i>
                                </div>
                            </div>
                        </div>

                        <div class="space-y-6">
                            <div class="bg-gray-800 p-6 rounded-xl shadow-lg">
                                <div class="flex items-center mb-4">
                                    <i data-lucide="user-x" class="h-6 w-6 text-red-400 mr-3"></i>
                                    <h3 class="text-lg font-semibold text-white">Abonamente pe terminate</h3>
                                </div>
                                <ul class="space-y-2 h-32 overflow-y-auto">
                                    ${endingSubscriptions.length > 0 ? endingSubscriptions.map(client => `
                                        <li class="text-sm text-gray-300 flex justify-between">
                                            <span>${client.name}</span>
                                            <span class="font-medium text-gray-400">${client.discipline}</span>
                                        </li>
                                    `).join('') : '<p class="text-sm text-gray-400">Niciun abonament pe terminate.</p>'}
                                </ul>
                            </div>
                        </div>

                        <div class="md:col-span-2 bg-gray-800 p-6 rounded-xl shadow-lg">
                            <div class="flex items-center mb-4">
                                <i data-lucide="pie-chart" class="h-6 w-6 text-blue-400 mr-3"></i>
                                <h3 class="text-lg font-semibold text-white">Distribuție pe Discipline</h3>
                            </div>
                            <div class="space-y-3">
                                ${disciplineChartHTML || '<p class="text-sm text-gray-400">Nu sunt date despre discipline.</p>'}
                            </div>
                        </div>
                    </div>
                `;
                dom.resultsArea.innerHTML = dashboardHTML;
                lucide.createIcons();
            };

            const renderAddAppointmentView = () => {
                dom.resultsArea.innerHTML = `
                    <div class="bg-gray-800 shadow-xl rounded-2xl overflow-hidden fade-in">
                        <div class="px-6 py-4 bg-gray-700 border-b border-gray-600">
                            <h2 class="text-2xl font-bold text-gray-200">Adaugă Programare</h2>
                        </div>
                        <div class="p-6">
                            <div id="availability-schedule" class="flex overflow-x-auto space-x-4 pb-4">
                                </div>
                        </div>
                    </div>
                `;
                renderAvailabilitySchedule();
            };

            const renderAvailabilitySchedule = async () => {
                const container = document.getElementById('availability-schedule');
                if (!container) return;

                container.innerHTML = `<div class="flex items-center justify-center p-10 w-full"><i data-lucide="loader-2" class="h-8 w-8 animate-spin text-blue-400"></i><span class="ml-3 text-lg">Se încarcă disponibilitatea...</span></div>`;
                lucide.createIcons();

                try {
                    const startDate = new Date();
                    startDate.setHours(0, 0, 0, 0);
                    const endDate = new Date();
                    endDate.setDate(startDate.getDate() + 20); // Fetch a bit more to account for skipped days

                    const allEvents = await api.getEventsForDateRange(startDate, endDate, true);

                    let scheduleHTML = '';
                    let daysShown = 0;
                    let dayOffset = 0;
                    const dayNames = ['Duminică', 'Luni', 'Marți', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'];

                    while (daysShown < 14) {
                        const currentDate = new Date(startDate);
                        currentDate.setDate(startDate.getDate() + dayOffset);
                        dayOffset++;

                        const dayOfWeek = currentDate.getDay();
                        const dayName = dayNames[dayOfWeek];
                        const workHoursRule = state.workingHours[dayName];

                        // Skip if it's Sunday or if the day is disabled in settings
                        if (dayOfWeek === 0 || !workHoursRule || !workHoursRule.enabled) {
                            continue;
                        }

                        daysShown++;

                        const doubleBookingRule = state.doubleBookingRules[dayName];

                        const dayStart = new Date(currentDate);
                        dayStart.setHours(0, 0, 0, 0);
                        const dayEnd = new Date(currentDate);
                        dayEnd.setHours(23, 59, 59, 999);

                        const eventsForDay = allEvents.filter(event => {
                            const eventStart = new Date(event.start.dateTime || event.start.date);
                            return eventStart >= dayStart && eventStart <= dayEnd;
                        });

                        const activeEventsForDay = eventsForDay.filter(event => {
                            const isDeclinedByOrganizer = event.attendees?.find(a => a.organizer)?.responseStatus === 'declined';
                            return event.status !== 'cancelled' && !isDeclinedByOrganizer;
                        });

                        const busySlots = activeEventsForDay.map(event => ({
                            start: new Date(event.start.dateTime || event.start.date),
                            end: new Date(event.end.dateTime || event.end.date)
                        }));

                        let daySlotsHTML = '';
                        const slotDuration = 60; // minutes

                        for (let hour = workHoursRule.startTime; hour < workHoursRule.endTime; hour++) {
                            const slotStart = new Date(currentDate);
                            slotStart.setHours(hour, 0, 0, 0);
                            const slotEnd = new Date(slotStart);
                            slotEnd.setMinutes(slotStart.getMinutes() + slotDuration);
                            const timeString = slotStart.toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' });

                            const isDoubleBookingTime = doubleBookingRule && doubleBookingRule.enabled && hour >= doubleBookingRule.startTime && hour < doubleBookingRule.endTime;

                            if (isDoubleBookingTime) {
                                const overlappingEvents = busySlots.filter(busySlot => (slotStart < busySlot.end && slotEnd > busySlot.start));
                                const busyCount = overlappingEvents.length;

                                if (busyCount < 2) {
                                    if (busyCount === 0) {
                                        daySlotsHTML += `<button class="time-slot-btn w-full text-left p-2 rounded-md transition-colors duration-200 bg-gray-700 hover:bg-blue-600 text-gray-200" data-start-time="${slotStart.toISOString()}" data-end-time="${slotEnd.toISOString()}">${timeString} (Slot 1)</button>`;
                                    }
                                    daySlotsHTML += `<button class="time-slot-btn w-full text-left p-2 rounded-md transition-colors duration-200 bg-gray-700 hover:bg-blue-600 text-gray-200" data-start-time="${slotStart.toISOString()}" data-end-time="${slotEnd.toISOString()}">${timeString} (Slot 2)</button>`;
                                }
                            } else {
                                const isBusy = busySlots.some(busySlot => (slotStart < busySlot.end && slotEnd > busySlot.start));
                                if (!isBusy) {
                                    daySlotsHTML += `<button class="time-slot-btn w-full text-left p-2 rounded-md transition-colors duration-200 bg-gray-700 hover:bg-blue-600 text-gray-200" data-start-time="${slotStart.toISOString()}" data-end-time="${slotEnd.toISOString()}">${timeString}</button>`;
                                }
                            }
                        }

                        const dateString = currentDate.toLocaleDateString('ro-RO', { day: 'numeric', month: 'long' });

                        scheduleHTML += `
                            <div class="day-schedule flex-shrink-0 w-48 bg-gray-700/50 rounded-lg p-3">
                                <h3 class="font-bold text-center text-blue-400">${dayName}</h3>
                                <p class="text-sm text-center text-gray-400 mb-3">${dateString}</p>
                                <div class="space-y-2">
                                    ${daySlotsHTML || '<p class="text-xs text-center text-gray-500 py-4">Niciun interval disponibil</p>'}
                                </div>
                            </div>
                        `;
                    }

                    container.innerHTML = scheduleHTML;
                    attachTimeSlotEventListeners();

                } catch (err) {
                    renderNotification(`Eroare la preluarea disponibilității: ${err.message}`, 'error');
                    container.innerHTML = `<p class="text-red-400 p-4">Nu s-a putut încărca programul.</p>`;
                } finally {
                    lucide.createIcons();
                }
            };

            const renderReportsView = () => {
                const today = new Date().toISOString().split('T')[0];
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                const thirtyDaysAgoStr = thirtyDaysAgo.toISOString().split('T')[0];

                dom.resultsArea.innerHTML = `
                    <div class="bg-gray-800 shadow-xl rounded-2xl overflow-hidden fade-in p-6 space-y-8">
                        <div id="attendance-report-section" class="report-section border border-gray-700 rounded-lg p-6">
                            <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
                                <h3 class="text-xl font-bold text-white">Raport de Prezență</h3>
                                <button id="export-attendance" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 flex items-center gap-2 text-sm"><i data-lucide="download" class="h-4 w-4"></i>Exportă CSV</button>
                            </div>
                            <div class="flex flex-col sm:flex-row sm:items-end gap-4 mb-4">
                                <div class="flex-grow">
                                    <label for="attendance-start-date" class="block text-sm font-medium text-gray-300 mb-1">Data de început</label>
                                    <input type="date" id="attendance-start-date" value="${thirtyDaysAgoStr}" class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </div>
                                <div class="flex-grow">
                                    <label for="attendance-end-date" class="block text-sm font-medium text-gray-300 mb-1">Data de sfârșit</label>
                                    <input type="date" id="attendance-end-date" value="${today}" class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </div>
                                <button id="generate-attendance-report" class="w-full sm:w-auto bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 flex-shrink-0">Generează Raport</button>
                            </div>
                            <div id="attendance-report-results" class="overflow-x-auto"></div>
                        </div>
                        
                        <div id="retention-report-section" class="report-section border border-gray-700 rounded-lg p-6">
                            <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
                                <h3 class="text-xl font-bold text-white">Raport Retenție Clienți</h3>
                                <button id="export-retention" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 flex items-center gap-2 text-sm"><i data-lucide="download" class="h-4 w-4"></i>Exportă CSV</button>
                            </div>
                             <div class="flex flex-wrap gap-4 items-end mb-4">
                                <button id="generate-retention-report" class="w-full sm:w-auto bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Generează Raport de Retenție (Ultimele 90 de zile)</button>
                            </div>
                            <div id="retention-report-results" class="overflow-x-auto"></div>
                        </div>
                    </div>
                `;
                lucide.createIcons();
                attachReportsEventListeners();
            };

            const renderFinancialsView = () => {
                const today = new Date().toISOString().split('T')[0];
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                const thirtyDaysAgoStr = thirtyDaysAgo.toISOString().split('T')[0];

                dom.resultsArea.innerHTML = `
                    <div class="bg-gray-800 shadow-xl rounded-2xl overflow-hidden fade-in p-6 space-y-8">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="bg-gray-700/50 p-6 rounded-xl flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium text-gray-400">Venituri (ultimele 30 de zile)</p>
                                    <p id="revenue-stat" class="text-4xl font-bold text-white">... RON</p>
                                </div>
                                <div class="bg-green-500/20 p-3 rounded-full">
                                    <i data-lucide="trending-up" class="h-8 w-8 text-green-400"></i>
                                </div>
                            </div>
                            <div class="bg-gray-700/50 p-6 rounded-xl flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium text-gray-400">Cheltuială medie/client</p>
                                    <p id="avg-spend-stat" class="text-4xl font-bold text-white">... RON</p>
                                </div>
                                <div class="bg-blue-500/20 p-3 rounded-full">
                                    <i data-lucide="wallet" class="h-8 w-8 text-blue-400"></i>
                                </div>
                            </div>
                        </div>

                        <div id="payments-list-section" class="report-section border border-gray-700 rounded-lg p-6">
                             <div class="flex flex-col md:flex-row md:justify-between md:items-center mb-4 gap-4">
                                <h3 class="text-xl font-bold text-white">Istoric Plăți</h3>
                                <div class="relative w-full md:w-1/3">
                                    <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3"><i data-lucide="search" class="h-5 w-5 text-gray-400"></i></div>
                                    <input type="text" id="financial-client-search" placeholder="Caută client sau email..." class="block w-full rounded-md border-gray-600 bg-gray-900/50 pl-10 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                                </div>
                            </div>
                            <div class="flex flex-col sm:flex-row sm:items-end gap-4 mb-4">
                                <div class="flex-grow">
                                    <label for="payments-start-date" class="block text-sm font-medium text-gray-300 mb-1">Data de început</label>
                                    <input type="date" id="payments-start-date" value="${thirtyDaysAgoStr}" class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </div>
                                <div class="flex-grow">
                                    <label for="payments-end-date" class="block text-sm font-medium text-gray-300 mb-1">Data de sfârșit</label>
                                    <input type="date" id="payments-end-date" value="${today}" class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </div>
                                <button id="generate-payments-list" class="w-full sm:w-auto bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 flex-shrink-0">Generează Listă</button>
                            </div>
                            <div id="payments-list-results" class="overflow-x-auto"></div>
                        </div>
                    </div>
                `;
                lucide.createIcons();
                attachFinancialsEventListeners();
            };

            // NEW FUNCTION 1: Fetches data and calls the renderer
            const loadAndDisplayTimesheet = async () => {
                state.isLoading = true;
                renderLoader('Se încarcă pontajul...');

                try {
                    state.timesheet = await firestoreApi.getTimesheetData();

                    renderLoader('Se încarcă datele financiare ale clienților...');
                    const allClientNames = [...new Set(
                        Object.values(state.timesheet).flatMap(ts =>
                            Object.values(ts.sessions || {}).flat().map(s => s.clientName)
                        )
                    )];
                    state.timesheetClientData = await getClientFinancialData(allClientNames);

                    // Now that data is loaded into state, render the view
                    renderFilteredTimesheet();

                } catch (err) {
                    renderNotification(`Eroare la încărcarea pontajului: ${err.message}`, 'error');
                    dom.resultsArea.innerHTML = '';
                } finally {
                    state.isLoading = false;
                }
            };

            // NEW FUNCTION 2: Renders the UI with filters
            // REPLACED FUNCTION: renderFilteredTimesheet
          // REPLACEMENT for renderFilteredTimesheet
            const renderFilteredTimesheet = () => {
                const instructors = state.instructors;
                // NOTE: clientFinancials is no longer needed here as data is pre-calculated

                if (instructors.length === 0) {
                    dom.resultsArea.innerHTML = `<div class="text-center py-12"><p class="text-lg text-gray-400">Nu sunt instructori de afișat.</p></div>`;
                    return;
                }

                // ... (year and month filter HTML generation remains the same) ...
                const allYears = [...new Set(
                    Object.values(state.timesheet).flatMap(ts =>
                        Object.keys(ts.sessions || {}).map(dateKey => new Date(dateKey).getFullYear())
                    )
                )].sort((a, b) => b - a);

                const yearOptions = allYears.map(y => `<option value="${y}" ${y === state.timesheetFilter.year ? 'selected' : ''}>${y}</option>`).join('');
                const monthOptions = [
                    "Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie",
                    "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"
                ].map((m, i) => `<option value="${i}" ${i === state.timesheetFilter.month ? 'selected' : ''}>${m}</option>`).join('');

                const filterHTML = `
    <div class="bg-gray-800 shadow-xl rounded-2xl p-4 mb-6 flex flex-col sm:flex-row gap-4 items-center">
        <h3 class="text-lg font-semibold text-white flex-shrink-0">Filtrează Pontaj</h3>
        <div class="flex-grow flex gap-4 w-full sm:w-auto">
            <select id="month-filter" class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                ${monthOptions}
            </select>
            <select id="year-filter" class="w-full px-3 py-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                ${yearOptions}
            </select>
        </div>
    </div>
    `;

                const instructorCardsHTML = instructors.map(instructor => {
                    const instructorTimesheet = state.timesheet[instructor.id] || { sessions: {} };
                    const sortedDays = Object.keys(instructorTimesheet.sessions || {}).sort((a, b) => new Date(b) - new Date(a));

                    let totalMonthlyCommission = 0;

                    const filteredDays = sortedDays.filter(dateKey => {
                        const date = new Date(dateKey);
                        return date.getFullYear() === state.timesheetFilter.year && date.getMonth() === state.timesheetFilter.month;
                    });

                    const dayCardsHTML = filteredDays.map(dateKey => {
                        const dayData = instructorTimesheet.sessions[dateKey] || { sessionList: [], totalCommission: 0 };
                        const sessions = dayData.sessionList;
                        const dailyTotalCommission = dayData.totalCommission || 0;

                        totalMonthlyCommission += dailyTotalCommission;

                        const sessionListHTML = sessions.map(session => {
                            const commission = session.commission || 0;
                            return `
                <li class="flex justify-between items-center text-sm p-2 bg-gray-900/50 rounded">
                    <div class="flex-1">
                        <span>${session.clientName} - ${session.discipline}</span>
                        <span class="block text-xs font-mono text-blue-300">${session.time}</span>
                    </div>
                    <span class="font-semibold text-lg ${commission > 0 ? 'text-green-400' : 'text-gray-500'} ml-4">
                        ${commission.toFixed(2)} RON
                    </span>
                </li>
            `;
                        }).join('');

                        const date = new Date(dateKey);
                        const dayName = date.toLocaleDateString('ro-RO', { weekday: 'long' });
                        const formattedDate = date.toLocaleDateString('ro-RO', { day: '2-digit', month: '2-digit', year: 'numeric' });
                        const displayDate = `${dayName.charAt(0).toUpperCase() + dayName.slice(1)} - ${formattedDate}`;

                        return `
            <div class="day-card mt-2">
                <button class="day-header w-full flex justify-between items-center p-2 bg-gray-700 hover:bg-gray-600 rounded-md text-left">
                    <span class="font-semibold text-gray-100">${displayDate}</span>
                    <div class="flex items-center">
                        <span class="font-bold text-lg text-green-400 mr-4">${dailyTotalCommission.toFixed(2)} RON</span>
                        <i data-lucide="chevron-down" class="h-5 w-5 text-gray-400 transition-transform"></i>
                    </div>
                </button>
                <ul class="day-sessions-list mt-2 pl-4 space-y-1" style="display: none;">
                    ${sessionListHTML}
                </ul>
            </div>
        `;
                    }).join('');

                    return `
        <div class="bg-gray-800 shadow-lg rounded-xl overflow-hidden instructor-card mb-4">
            <button class="instructor-header w-full flex justify-between items-center p-4 bg-gray-700/50 hover:bg-gray-700 text-left">
                <div class="flex flex-col sm:flex-row sm:items-center gap-x-4">
                    <h3 class="text-xl font-bold text-white">${instructor.name}</h3>
                    <span class="text-sm font-semibold text-gray-300">Total Lunar: <span class="text-xl text-green-400 font-bold">${totalMonthlyCommission.toFixed(2)} RON</span></span>
                </div>
                <i data-lucide="chevron-down" class="h-6 w-6 text-gray-300 transition-transform flex-shrink-0"></i>
            </button>
            <div class="instructor-details p-4 border-t border-gray-600" style="display: none;">
                ${dayCardsHTML || `<p class="text-sm text-center text-gray-400 py-4">Nicio sesiune înregistrată pentru luna selectată.</p>`}
            </div>
        </div>
    `;
                }).join('');

                dom.resultsArea.innerHTML = `
    <div class="fade-in">
        ${filterHTML}
        <div id="instructor-cards-container">
            ${instructorCardsHTML}
        </div>
    </div>
    `;

                // ... (event listeners at the end of the function remain the same) ...
                document.getElementById('month-filter').addEventListener('change', (e) => {
                    state.timesheetFilter.month = parseInt(e.target.value, 10);
                    renderFilteredTimesheet();
                });
                document.getElementById('year-filter').addEventListener('change', (e) => {
                    state.timesheetFilter.year = parseInt(e.target.value, 10);
                    renderFilteredTimesheet();
                });

                document.querySelectorAll('.instructor-header, .day-header').forEach(header => {
                    header.addEventListener('click', () => {
                        const content = header.nextElementSibling;
                        const icon = header.querySelector('.lucide-chevron-down');
                        if (content && icon) {
                            const isVisible = content.style.display !== 'none';
                            content.style.display = isVisible ? 'none' : 'block';
                            icon.classList.toggle('rotate-180', !isVisible);
                        }
                    });
                });

                lucide.createIcons();
            };
            // --- EVENT HANDLERS ---
            const handleTabChange = async () => {
                if (state.activeTab === 'instructors') {
                    renderInstructorsView();
                    return;
                }
                if (state.activeTab === 'settings') {
                    renderSettingsView();
                    return;
                }
                if (state.activeTab === 'timesheet') {
                    loadAndDisplayTimesheet(); // MODIFIED
                    return;
                }
                if (state.activeTab === 'dashboard') {
                    handleDashboardLoad();
                    return;
                }
                if (state.activeTab === 'add') {
                    renderAddAppointmentView();
                    return;
                }
                if (state.activeTab === 'reports') {
                    renderReportsView();
                    return;
                }
                if (state.activeTab === 'financials') {
                    renderFinancialsView();
                    return;
                }

                if (!state.accessToken || !state.calendarId) {
                    renderNotification('Autentificarea este necesară și ID-ul de Calendar trebuie setat.', 'error');
                    return;
                }
                state.isLoading = true;
                state.searchQuery = '';
                dom.searchQueryInput.value = '';
                renderLoader('Se încarcă...');
                updateUI();

                try {
                    state.clients = await api.getEvents(state.activeTab);
                    const clientDataPromises = Object.keys(state.clients).map(name => firestoreApi.getClientData(name));
                    const clientFirebaseDataArray = await Promise.all(clientDataPromises);
                    state.clientFirebaseData = clientFirebaseDataArray.reduce((acc, data) => {
                        if (data.name) {
                            acc[data.name] = data;
                        }
                        return acc;
                    }, {});

                    await fetchAndMergeLastPayments(state.clients, state.clientFirebaseData);

                    populateDisciplineFilter(state.clients);
                    renderClients(state.clients, state.clientFirebaseData);
                } catch (err) {
                    renderNotification(`Eroare la preluarea evenimentelor: ${err.message}`, 'error');
                    dom.resultsArea.innerHTML = '';
                } finally {
                    state.isLoading = false;
                    updateUI();
                }
            };

            const handleDashboardLoad = async () => {
                renderLoader('Se calculează datele pentru dashboard...');
                try {
                    // Calculate date range: last Monday to next Sunday
                    const today = new Date();
                    const dayOfWeek = today.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
                    const lastMonday = new Date(today);
                    const diffToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                    lastMonday.setDate(today.getDate() - diffToMonday);
                    lastMonday.setHours(0, 0, 0, 0);

                    const nextSunday = new Date(lastMonday);
                    nextSunday.setDate(lastMonday.getDate() + 6);
                    nextSunday.setHours(23, 59, 59, 999);

                    const options = { day: 'numeric', month: 'long' };
                    const dateRangeString = `${lastMonday.toLocaleDateString('ro-RO', options)} - ${nextSunday.toLocaleDateString('ro-RO', { ...options, year: 'numeric' })}`;

                    // Fetch events for the calculated week
                    const weeklyEventsRaw = await api.getEventsForDateRange(lastMonday, nextSunday);

                    const allClients = await api.getEvents('all');

                    // 1. Total Active Students
                    const totalStudents = Object.keys(allClients).length;

                    // 2. Sessions This Week
                    const sessionsThisWeek = weeklyEventsRaw.filter(event => event.status !== 'cancelled').length;

                    // 3. Subscriptions Ending Soon
                    const clientDataPromises = Object.keys(allClients).map(name => firestoreApi.getClientData(name));
                    const allClientFirebaseData = await Promise.all(clientDataPromises);
                    const endingSubscriptions = [];
                    allClientFirebaseData.forEach(clientData => {
                        const clientDetails = allClients[clientData.name];
                        if (clientDetails) {
                            const subType = parseInt(clientData.subscription || '4');
                            if (clientDetails.sessionNumber === subType) {
                                endingSubscriptions.push({ name: clientData.name, discipline: clientDetails.discipline });
                            }
                        }
                    });

                    // 4. Discipline Breakdown
                    const disciplineBreakdown = Object.values(allClients).reduce((acc, client) => {
                        acc[client.discipline] = (acc[client.discipline] || 0) + 1;
                        return acc;
                    }, {});

                    renderDashboard({
                        totalStudents,
                        sessionsThisWeek,
                        endingSubscriptions,
                        disciplineBreakdown,
                        dateRangeString
                    });

                } catch (err) {
                    renderNotification(`Eroare la încărcarea datelor pentru dashboard: ${err.message}`, 'error');
                    dom.resultsArea.innerHTML = '';
                }
            };

            const handleSearch = async () => {
                if (state.searchQuery.trim().length < 3) {
                    state.clients = {};
                    renderClients({});
                    return;
                }
                state.isSearching = true;
                renderLoader('Se caută...');
                updateUI();

                try {
                    state.clients = await api.searchEvents(state.searchQuery);
                    const clientDataPromises = Object.keys(state.clients).map(name => firestoreApi.getClientData(name));
                    const clientFirebaseDataArray = await Promise.all(clientDataPromises);
                    state.clientFirebaseData = clientFirebaseDataArray.reduce((acc, data) => {
                        if (data.name) {
                            acc[data.name] = data;
                        }
                        return acc;
                    }, {});
                    await fetchAndMergeLastPayments(state.clients, state.clientFirebaseData);
                    populateDisciplineFilter(state.clients);
                    renderClients(state.clients, state.clientFirebaseData);
                } catch (err) {
                    renderNotification(`Căutarea a eșuat: ${err.message}`, 'error');
                    dom.resultsArea.innerHTML = '';
                } finally {
                    state.isSearching = false;
                    updateUI();
                }
            };

            const handleDeclineClick = (button) => {
                const { eventId, name, discipline, phone } = button.dataset;
                state.cancellationContext = { eventId, name, discipline, phone, originalButton: button };
                showModal(dom.cancelModal);
            };

            const handleLogCashClick = (button) => {
                const { eventId, name } = button.dataset;
                state.cashPaymentContext = { eventId, name };
                showCashPaymentModal(name, eventId);
            };

            const handlePostHomeworkClick = async (button) => {
                const form = button.closest('.homework-form');
                const { name } = form.dataset;
                const { studentEmail, discipline } = button.dataset;
                const courseId = form.querySelector('.course-select').value;
                const homework = form.querySelector('.homework-text').value;

                if (!homework || !studentEmail || !courseId) {
                    renderNotification("Te rugăm să selectezi un curs, să te asiguri că studentul are un e-mail și să scrii tema.", "error");
                    return;
                }

                button.innerHTML = `<i data-lucide="loader-2" class="h-4 w-4 animate-spin"></i><span>Se postează...</span>`;
                button.disabled = true;
                lucide.createIcons();

                try {
                    await api.postHomework({ courseId, studentEmail, discipline, homework });
                    renderNotification(`Tema a fost postată pentru ${name}`, 'success');
                    form.querySelector('.homework-text').value = '';
                } catch (err) {
                    renderNotification(`Eroare la postarea temei: ${err.message}`, 'error');
                } finally {
                    button.innerHTML = `<i data-lucide="book" class="h-4 w-4 mr-1.5"></i><span>Postează Tema</span>`;
                    button.disabled = false;
                    lucide.createIcons();
                }
            };

            const handleIncrementSessionClick = async (button) => {
                const { eventId, name } = button.dataset;
                const clientDetails = state.clients[name];
                const clientFirebaseData = state.clientFirebaseData[name] || { subscription: '4' };
                const subscriptionMax = parseInt(clientFirebaseData.subscription);

                if (!clientDetails || (state.activeTab !== 'today' && state.activeTab !== 'tomorrow')) {
                    renderNotification('Incrementarea sesiunilor este disponibilă doar pentru sesiunile de astăzi sau de mâine.', 'error');
                    return;
                }

                button.innerHTML = `<i data-lucide="loader-2" class="h-4 w-4 animate-spin"></i>`;
                button.disabled = true;
                lucide.createIcons();

                try {
                    let newSessionNumber;
                    let lastSessionNumber = 0;

                    if (state.activeTab === 'tomorrow') {
                        renderNotification('Se caută ultima sesiune trecută...', 'success');
                        const lastEvent = await api.findLastPastEvent(name);
                        if (lastEvent && lastEvent.summary) {
                            const parts = lastEvent.summary.split(' - ').map(p => p.trim());
                            if (parts.length >= 3) {
                                const sessionPart = parts[2];
                                const parsedNumber = parseInt(sessionPart.toLowerCase().replace('sedinta', '').replace('#', ''), 10);
                                if (!isNaN(parsedNumber)) {
                                    lastSessionNumber = parsedNumber;
                                }
                            }
                        }
                    } else { // 'today' tab
                        lastSessionNumber = clientDetails.sessionNumber;
                    }

                    newSessionNumber = (lastSessionNumber % subscriptionMax) + 1;

                    let colorToApply = null;
                    if (newSessionNumber === 1) {
                        colorToApply = '10'; // Green (Basil)
                    } else if (newSessionNumber === subscriptionMax) {
                        colorToApply = '11'; // Red (Tomato)
                    } else {
                        colorToApply = '8'; // Gray (Graphite)
                    }

                    const newSummary = `${name} - ${clientDetails.discipline} - Sedinta ${newSessionNumber}`;
                    await api.updateEventSummary(eventId, newSummary, colorToApply);
                    renderNotification(`Sesiunea pentru ${name} a fost incrementată la ${newSessionNumber}.`, 'success');

                    state.clients[name].sessionNumber = newSessionNumber;
                    renderClients(state.clients, state.clientFirebaseData);

                } catch (err) {
                    renderNotification(`Eroare la incrementarea sesiunii pentru ${name}: ${err.message}`, 'error');
                } finally {
                    button.innerHTML = `<i data-lucide="plus-circle" class="h-4 w-4 mr-1.5"></i><span>Incrementeaza sedinta</span>`;
                    button.disabled = false;
                    lucide.createIcons();
                }
            };

            const handleIncrementAllTomorrow = async () => {
                if (state.activeTab !== 'tomorrow') return;

                const tomorrowClients = Object.entries(state.clients);
                if (tomorrowClients.length === 0) {
                    renderNotification("Nicio sesiune de incrementat pentru mâine.", "success");
                    return;
                }

                dom.incrementAllBtn.disabled = true;
                dom.incrementAllBtn.innerHTML = `<i data-lucide="loader-2" class="h-5 w-5 animate-spin mr-2"></i> Se incrementează...`;
                lucide.createIcons();

                for (const [name, details] of tomorrowClients) {
                    const clientLi = document.getElementById(`client-${details.eventId}`);
                    const button = clientLi?.querySelector('.increment-session-btn');
                    if (button) {
                        await handleIncrementSessionClick(button);
                    }
                }

                dom.incrementAllBtn.disabled = false;
                dom.incrementAllBtn.innerHTML = `Incrementează Toate Sesiunile pentru Mâine`;
                renderNotification("Toate sesiunile pentru mâine au fost incrementate.", "success");
            };

            const handleLogTodaysSessionsClick = async () => {
                const button = document.getElementById('logTodaysSessionsBtn');
                if (state.activeTab !== 'today' || Object.keys(state.clients).length === 0) {
                    renderNotification("Nicio sesiune de înregistrat pentru azi.", "success");
                    return;
                }

                button.disabled = true;
                button.innerHTML = `<i data-lucide="loader-2" class="h-5 w-5 animate-spin mr-2"></i> Se calculează și se înregistrează...`;
                lucide.createIcons();

                let loggedCount = 0;
                const todayKey = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD

                try {
                    // 1. Fetch financial data for all of today's clients first
                    const clientNames = Object.keys(state.clients);
                    const clientFinancials = await getClientFinancialData(clientNames);

                    // 2. Group sessions by instructor
                    const sessionsByInstructor = {};
                    for (const [clientName, details] of Object.entries(state.clients)) {
                        const clientData = state.clientFirebaseData[clientName];
                        const instructorId = clientData?.assignedInstructor ? state.instructors.find(i => i.name === clientData.assignedInstructor)?.id : null;

                        if (instructorId) {
                            if (!sessionsByInstructor[instructorId]) {
                                sessionsByInstructor[instructorId] = [];
                            }
                            sessionsByInstructor[instructorId].push({ clientName, details });
                        }
                    }

                    // 3. Process and log data for each instructor
                    for (const [instructorId, sessions] of Object.entries(sessionsByInstructor)) {
                        let dailyTotalCommission = 0;
                        const sessionList = [];
                        const instructorPercent = parseFloat(state.instructorPercentages[instructorId]) || 0;

                        for (const { clientName, details } of sessions) {
                            const financialData = clientFinancials[clientName];
                            let commission = 0;

                            if (financialData && instructorPercent > 0) {
                                const lastPayment = financialData.lastPaymentAmount || 0;
                                const subType = parseInt(financialData.subscription, 10) || 4;
                                if (lastPayment > 0 && subType > 0) {
                                    const sessionPrice = lastPayment / subType;
                                    commission = (sessionPrice * instructorPercent) / 100 - (sessionPrice * 0.06); // Deduct 6% tax
                                }
                            }

                            dailyTotalCommission += commission;
                            loggedCount++;

                            sessionList.push({
                                clientName: clientName,
                                discipline: details.discipline,
                                time: new Date(details.startTime).toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' }),
                                commission: commission // Store the calculated commission
                            });
                        }

                        // 4. Log the entire day's data for the instructor
                        await firestoreApi.logDailyTimesheet(instructorId, todayKey, {
                            totalCommission: dailyTotalCommission,
                            sessionList: sessionList
                        });
                    }

                    renderNotification(`${loggedCount} sesiuni au fost înregistrate în pontaj.`, 'success');
                } catch (err) {
                    renderNotification(`Eroare la înregistrarea pontajului: ${err.message}`, 'error');
                } finally {
                    button.disabled = false;
                    button.innerHTML = `Înregistrează Pontajul de Azi`;
                }
            };

            const handleReportToInstructors = () => {
                if (state.activeTab !== 'tomorrow') return;
                const clientsByInstructor = {};
                for (const [clientName, details] of Object.entries(state.clients)) {
                    const clientData = state.clientFirebaseData[clientName];
                    const instructorName = clientData?.assignedInstructor;
                    if (instructorName) {
                        if (!clientsByInstructor[instructorName]) {
                            clientsByInstructor[instructorName] = [];
                        }
                        clientsByInstructor[instructorName].push({
                            name: clientName,
                            time: new Date(details.startTime).toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' })
                        });
                    }
                }

                const instructorsWithoutPhone = [];
                let reportsSent = 0;
                for (const [instructorName, clientList] of Object.entries(clientsByInstructor)) {
                    const instructor = state.instructors.find(inst => inst.name === instructorName);
                    if (instructor && instructor.phone) {
                        clientList.sort((a, b) => a.time.localeCompare(b.time));
                        let message = `Salut ${instructorName}! Mâine ai următoarele ședințe:\n`;
                        message += clientList.map(client => `- ${client.name} la ${client.time}`).join('\n');
                        const link = getWhatsAppLink(instructor.phone, message);
                        window.open(link, '_blank');
                        reportsSent++;
                    } else {
                        instructorsWithoutPhone.push(instructorName);
                    }
                }

                if (reportsSent > 0) {
                    renderNotification(`${reportsSent} rapoarte au fost generate.`, 'success');
                }
                if (instructorsWithoutPhone.length > 0) {
                    renderNotification(`Nu s-a putut trimite raportul pentru: ${instructorsWithoutPhone.join(', ')} (lipsește numărul de telefon).`, 'error');
                }
                if (reportsSent === 0 && instructorsWithoutPhone.length === 0) {
                    renderNotification('Niciun client alocat instructorilor pentru mâine.', 'success');
                }
            };

            const handleNotifyInstructor = async (instructorId, instructorName, instructorPhone) => {
                if (!instructorPhone) {
                    renderNotification(`Instructorul ${instructorName} nu are un număr de telefon salvat.`, 'error');
                    return;
                }
                renderLoader('Se preiau programările pentru mâine...');
                try {
                    const tomorrowsClients = await api.getEvents('tomorrow');
                    const clientDataPromises = Object.keys(tomorrowsClients).map(name => firestoreApi.getClientData(name));
                    const clientFirebaseDataArray = await Promise.all(clientDataPromises);
                    const clientFirebaseData = clientFirebaseDataArray.reduce((acc, data) => {
                        if (data.name) {
                            acc[data.name] = data;
                        }
                        return acc;
                    }, {});
                    const instructorClients = [];
                    for (const [clientName, details] of Object.entries(tomorrowsClients)) {
                        if (clientFirebaseData[clientName]?.assignedInstructor === instructorName) {
                            instructorClients.push({
                                name: clientName,
                                time: new Date(details.startTime).toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' })
                            });
                        }
                    }
                    dom.resultsArea.innerHTML = '';
                    renderInstructorsView();
                    if (instructorClients.length === 0) {
                        renderNotification(`Instructorul ${instructorName} nu are clienți programați pentru mâine.`, 'success');
                        return;
                    }
                    instructorClients.sort((a, b) => a.time.localeCompare(b.time));
                    let message = `Salut ${instructorName}! Mâine ai următoarele ședințe:\n`;
                    message += instructorClients.map(client => `- ${client.name} la ${client.time}`).join('\n');
                    const link = getWhatsAppLink(instructorPhone, message);
                    window.open(link, '_blank');
                    renderNotification(`Raport generat pentru ${instructorName}.`, 'success');
                } catch (err) {
                    renderNotification(`Eroare la generarea raportului: ${err.message}`, 'error');
                    renderInstructorsView();
                }
            };

            // --- EVENT LISTENERS ---
            function attachAppEventListeners() {
                dom.calendarIdInput.addEventListener('change', (e) => state.calendarId = e.target.value);
                dom.incrementAllBtn.addEventListener('click', handleIncrementAllTomorrow);
                document.getElementById('logTodaysSessionsBtn').addEventListener('click', handleLogTodaysSessionsClick);

                dom.openCalendarBtn.addEventListener('click', () => {
                    const calendarId = dom.calendarIdInput.value;
                    if (calendarId) {
                        const url = `https://calendar.google.com/calendar/u/0/r?cid=${encodeURIComponent(calendarId)}`;
                        window.open(url, '_blank');
                    } else {
                        renderNotification('Te rugăm să introduci mai întâi un ID de Calendar.', 'error');
                    }
                });

                let searchTimeout;
                dom.searchQueryInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    state.searchQuery = e.target.value;
                    if (state.searchQuery.trim()) {
                        dom.tabControls.style.display = 'none';
                        searchTimeout = setTimeout(handleSearch, 500);
                    } else {
                        dom.tabControls.style.display = 'block';
                        handleTabChange();
                    }
                });

                dom.tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        state.activeTab = button.dataset.tab;
                        dom.resultsArea.innerHTML = ''; // Clear previous results
                        updateUI();
                        handleTabChange();
                    });
                });

                dom.disciplineFilter.addEventListener('change', (e) => {
                    state.activeDiscipline = e.target.value;
                    renderClients(state.clients, state.clientFirebaseData);
                });

                dom.lastSessionFilter.addEventListener('change', (e) => {
                    state.filterLastSessionOnly = e.target.checked;
                    renderClients(state.clients, state.clientFirebaseData);
                });

                dom.closeModalBtn.addEventListener('click', () => hideModal(dom.cancelModal));
                dom.cancelModal.addEventListener('click', (e) => {
                    if (e.target === dom.cancelModal) hideModal(dom.cancelModal);
                });
                dom.cancelByInstructorBtn.addEventListener('click', handleCancelByInstructor);
                dom.cancelByClientBtn.addEventListener('click', handleCancelByClient);

                // New event modal listeners
                dom.closeCreateModalBtn.addEventListener('click', () => hideModal(dom.createEventModal));
                dom.createEventModal.addEventListener('click', (e) => {
                    if (e.target === dom.createEventModal) hideModal(dom.createEventModal);
                });
                dom.createEventForm.addEventListener('submit', handleCreateEventSubmit);

                // Cash payment modal listeners
                dom.closeCashModalBtn.addEventListener('click', () => hideModal(dom.cashPaymentModal));
                dom.cashPaymentModal.addEventListener('click', (e) => {
                    if (e.target === dom.cashPaymentModal) hideModal(dom.cashPaymentModal);
                });
                dom.cashPaymentForm.addEventListener('submit', handleCashPaymentSubmit);
            }

            const attachClientEventListeners = () => {
                document.querySelectorAll('.client-header').forEach(header => {
                    header.addEventListener('click', (e) => {
                        if (e.target.closest('a')) {
                            return;
                        }
                        const name = header.dataset.name;
                        const detailsContainer = header.parentElement.querySelector('.client-details');
                        const isOpening = state.expandedClient !== name;

                        if (state.expandedClient && state.expandedClient !== name) {
                            const oldHeader = Array.from(document.querySelectorAll('.client-header')).find(h => h.dataset.name === state.expandedClient);
                            if (oldHeader) {
                                oldHeader.parentElement.querySelector('.client-details').style.display = 'none';
                                oldHeader.querySelector('.chevron-icon-wrapper')?.classList.remove('rotate-180');
                            }
                        }

                        state.expandedClient = isOpening ? name : null;
                        detailsContainer.style.display = isOpening ? 'block' : 'none';
                        header.querySelector('.chevron-icon-wrapper')?.classList.toggle('rotate-180', isOpening);

                        if (isOpening) {
                            renderClientDetails(name, detailsContainer);
                        }
                    });
                });

                document.querySelectorAll('.whatsapp-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const { phone, message } = e.currentTarget.dataset;
                        const link = getWhatsAppLink(phone, message);
                        if (link) window.open(link, '_blank');
                        else renderNotification('Niciun număr de telefon disponibil pentru acest client.', 'error');
                    });
                });

                document.querySelectorAll('.decline-btn').forEach(button => {
                    button.addEventListener('click', (e) => { e.stopPropagation(); handleDeclineClick(e.currentTarget); });
                });

                document.querySelectorAll('.log-cash-btn').forEach(button => {
                    button.addEventListener('click', (e) => { e.stopPropagation(); handleLogCashClick(e.currentTarget); });
                });

                document.querySelectorAll('.increment-session-btn').forEach(button => {
                    button.addEventListener('click', (e) => { e.stopPropagation(); handleIncrementSessionClick(e.currentTarget); });
                });

                document.querySelectorAll('.subscription-select, .instructor-select').forEach(select => {
                    select.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    select.addEventListener('change', async (e) => {
                        e.stopPropagation();
                        const clientName = e.target.dataset.name;
                        const statusEl = e.target.parentElement.querySelector('.sub-status');
                        let dataToSave = {};

                        if (e.target.classList.contains('subscription-select')) {
                            dataToSave = { subscription: e.target.value };
                            state.clientFirebaseData[clientName].subscription = e.target.value;
                        } else {
                            dataToSave = { assignedInstructor: e.target.value };
                            state.clientFirebaseData[clientName].assignedInstructor = e.target.value;
                        }

                        try {
                            await firestoreApi.saveClientData(clientName, dataToSave);
                            statusEl.classList.remove('opacity-0');
                            setTimeout(() => statusEl.classList.add('opacity-0'), 2000);
                            renderClients(state.clients, state.clientFirebaseData);
                        } catch (err) {
                            renderNotification(`Eroare la salvarea datelor: ${err.message}`, 'error');
                        }
                    });
                });
            };

            // NEW HELPER FUNCTION
            const createUpcomingEventsHTML = (events, client) => {
                if (events.length === 0) {
                    return `<p class="text-sm text-gray-400">Nicio programare viitoare în următoarele 30 de zile.</p>`;
                }
                return `<ul class="space-y-3">` + events.map(event => {
                    const startDate = new Date(event.start.dateTime || event.start.date);
                    const formattedDate = startDate.toLocaleDateString('ro-RO', { weekday: 'long', day: 'numeric', month: 'long' });
                    const formattedTime = startDate.toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' });
                    const discipline = event.summary.split(' - ')[1] || client.discipline;
                    const editUrl = getGoogleCalendarEditUrl(event.id);

                    return `
            <li class="p-3 bg-gray-900/50 rounded-lg flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                <div>
                    <p class="font-semibold text-gray-200">${event.summary}</p>
                    <p class="text-sm text-blue-400">${formattedDate} la ${formattedTime}</p>
                </div>
                <div class="flex items-center gap-2 flex-shrink-0">
                    <a href="${editUrl}" target="_blank" class="upcoming-reschedule-btn bg-yellow-600 text-white p-2 rounded-md hover:bg-yellow-700" title="Reprogramează în Google Calendar">
                        <i data-lucide="calendar-days" class="h-4 w-4"></i>
                    </a>
                    <button class="upcoming-cancel-btn bg-red-600 text-white p-2 rounded-md hover:bg-red-700" 
                        data-event-id="${event.id}" 
                        data-name="${client.name}" 
                        data-discipline="${discipline}"
                        data-phone="${client.phone}"
                        title="Anulează Sesiunea">
                        <i data-lucide="calendar-x" class="h-4 w-4"></i>
                    </button>
                </div>
            </li>
        `;
                }).join('') + `</ul>`;
            };

            // REPLACED FUNCTION
           const renderClientDetails = async (name, container) => {
                container.innerHTML = `<div class="p-4 border-t border-gray-700 flex justify-center"><i data-lucide="loader-2" class="h-6 w-6 animate-spin text-gray-500"></i></div>`;
                lucide.createIcons();
                try {
                    const client = state.clients[name];
                    const clientDataPromise = firestoreApi.getClientData(name);
                    const historyPromise = api.fetchHistory(name);
                    const upcomingEventsPromise = api.getUpcomingEvents(name);

                    const [clientData, history, upcomingEvents] = await Promise.all([clientDataPromise, historyPromise, upcomingEventsPromise]);

                    const historyHTML = createHistoryHTML(history);
                    const notesHTML = createNotesHTML(name, clientData.notes);
                    const homeworkHTML = createHomeworkHTML(name, client);
                    const upcomingEventsHTML = createUpcomingEventsHTML(upcomingEvents, { name, phone: client.phone, discipline: client.discipline });

                    container.innerHTML = `
            <div class="p-6 border-t border-gray-700 space-y-8">
                <div>
                    <button class="upcoming-events-header flex items-center justify-between w-full p-2 bg-gray-700 hover:bg-gray-600 rounded-md cursor-pointer">
                        <span class="text-lg font-semibold text-gray-200">Programări Viitoare (30 zile)</span>
                        <i data-lucide="chevron-down" class="h-5 w-5 text-gray-400 transition-transform"></i>
                    </button>
                    <div class="upcoming-events-list mt-2 pl-4" style="display: none;">
                        ${upcomingEventsHTML}
                    </div>
                </div>
                <div>
                    ${notesHTML}
                </div>
                <div>
                    ${homeworkHTML}
                </div>
                <div>
                    <h4 class="text-md font-semibold text-gray-200 mb-2">Istoric Sesiuni (Ultimele 60 de zile)</h4>
                    ${historyHTML}
                </div>
            </div>
        `;
                    lucide.createIcons();
                    attachDetailEventListeners(container);
                } catch (err) {
                    container.innerHTML = `<div class="p-4 border-t border-gray-700 text-red-500">Eroare la încărcarea detaliilor: ${err.message}</div>`;
                }
            };

            const attachDetailEventListeners = (container) => {
                const notesTextarea = container.querySelector('.notes-textarea');
                const notesStatus = container.querySelector('.notes-status');
                if (notesTextarea && notesStatus) {
                    const saveNotes = debounce(async (e) => {
                        const clientName = e.target.closest('.notes-section').dataset.clientName;
                        notesStatus.style.opacity = '1';
                        try {
                            await firestoreApi.saveClientData(clientName, { notes: e.target.value });
                            notesStatus.textContent = 'Salvat!';
                        } catch (err) {
                            notesStatus.textContent = 'Eroare!';
                            console.error("Failed to save notes:", err);
                        }
                        setTimeout(() => { notesStatus.style.opacity = '0'; }, 2000);
                    }, 1000);
                    notesTextarea.addEventListener('input', saveNotes);
                }

                container.querySelector('.post-homework-btn')?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handlePostHomeworkClick(e.currentTarget);
                });

                container.querySelectorAll('.history-month-header').forEach(header => {
                    header.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const list = header.nextElementSibling;
                        const iconWrapper = header.querySelector('.history-chevron-wrapper');
                        const isVisible = list.style.display !== 'none';
                        list.style.display = isVisible ? 'none' : 'block';
                        iconWrapper?.classList.toggle('rotate-180', !isVisible);
                    });
                });

                container.querySelectorAll('.upcoming-cancel-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleDeclineClick(e.currentTarget);
                    });
                });

                // NEW: Add listener for the upcoming events accordion
                container.querySelectorAll('.upcoming-events-header').forEach(header => {
                    header.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const list = header.nextElementSibling;
                        const icon = header.querySelector('.lucide-chevron-down');
                        if (list && icon) {
                            const isVisible = list.style.display !== 'none';
                            list.style.display = isVisible ? 'none' : 'block';
                            icon.classList.toggle('rotate-180', !isVisible);
                        }
                    });
                });
            };

            const attachInstructorEventListeners = () => {
                document.getElementById('addInstructorBtn')?.addEventListener('click', async () => {
                    const nameInput = document.getElementById('newInstructorName');
                    const phoneInput = document.getElementById('newInstructorPhone');
                    const name = nameInput.value.trim();
                    const phone = phoneInput.value.trim();
                    if (name) {
                        try {
                            await firestoreApi.addInstructor(name, phone);
                            renderNotification(`Instructorul "${name}" a fost adăugat.`, 'success');
                            nameInput.value = '';
                            phoneInput.value = '';
                        } catch (err) {
                            renderNotification(`Eroare la adăugarea instructorului: ${err.message}`, 'error');
                        }
                    }
                });
                
                attachInstructorDeleteListeners();
                attachInstructorPhoneInputListeners();
                attachInstructorNotifyListeners();
                attachInstructorPercentageListeners();
            };

            const attachInstructorPhoneInputListeners = () => {
                document.querySelectorAll('.instructor-phone-input').forEach(input => {
                    const savePhone = debounce(async (e) => {
                        const id = e.target.dataset.id;
                        const phone = e.target.value.trim();
                        try {
                            await firestoreApi.updateInstructor(id, { phone });
                            renderNotification('Numărul de telefon a fost actualizat.', 'success');
                        } catch (err) {
                            renderNotification(`Eroare la actualizarea numărului de telefon: ${err.message}`, 'error');
                        }
                    }, 1000);
                    input.addEventListener('input', savePhone);
                });
            };
            // NEW FUNCTION
            const attachInstructorPercentageListeners = () => {
                document.querySelectorAll('.instructor-percentage-input').forEach(input => {
                    const savePercentage = debounce(async (e) => {
                        const id = e.target.dataset.id;
                        const percentage = e.target.value.trim();
                        state.instructorPercentages[id] = percentage; // Update state immediately
                        try {
                            await firestoreApi.saveInstructorPercentages(state.instructorPercentages);
                            renderNotification('Procentajul a fost salvat.', 'success');
                        } catch (err) {
                            renderNotification(`Eroare la salvarea procentajului: ${err.message}`, 'error');
                        }
                    }, 1000);
                    input.addEventListener('input', savePercentage);
                });
            };

            const attachInstructorDeleteListeners = () => {
                document.querySelectorAll('.delete-instructor-btn').forEach(button => {
                    const newButton = button.cloneNode(true);
                    button.parentNode.replaceChild(newButton, button);
                    newButton.addEventListener('click', async (e) => {
                        const id = e.currentTarget.closest('button').dataset.id;
                        try {
                            await firestoreApi.deleteInstructor(id);
                            renderNotification('Instructor eliminat.', 'success');
                        } catch (err) {
                            renderNotification(`Eroare la eliminarea instructorului: ${err.message}`, 'error');
                        }
                    });
                });
            };

            const attachInstructorNotifyListeners = () => {
                document.querySelectorAll('.notify-instructor-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const { id, name, phone } = e.currentTarget.dataset;
                        handleNotifyInstructor(id, name, phone);
                    });
                });
            };

            const attachSettingsEventListeners = () => {
                document.getElementById('toggle-api-keys-btn')?.addEventListener('click', () => {
                    state.isApiKeysExpanded = !state.isApiKeysExpanded;
                    renderSettingsView();
                });

                document.getElementById('toggle-messages-btn')?.addEventListener('click', () => {
                    state.isSettingsExpanded = !state.isSettingsExpanded;
                    renderSettingsView();
                });

                document.getElementById('toggle-double-booking-btn')?.addEventListener('click', () => {
                    state.isDoubleBookingExpanded = !state.isDoubleBookingExpanded;
                    renderSettingsView();
                });

                document.getElementById('toggle-working-hours-btn')?.addEventListener('click', () => {
                    state.isWorkingHoursExpanded = !state.isWorkingHoursExpanded;
                    renderSettingsView();
                });

                document.querySelectorAll('.variable-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const targetId = e.target.dataset.target;
                        const value = e.target.dataset.value;
                        const textarea = document.getElementById(targetId);
                        if (textarea) {
                            const start = textarea.selectionStart;
                            const end = textarea.selectionEnd;
                            const text = textarea.value;
                            textarea.value = text.substring(0, start) + value + text.substring(end);
                            textarea.focus();
                            textarea.selectionEnd = start + value.length;
                        }
                    });
                });

                document.getElementById('save-messages-btn')?.addEventListener('click', async () => {
                    const button = document.getElementById('save-messages-btn');
                    button.disabled = true;
                    button.innerHTML = `<i data-lucide="loader-2" class="h-5 w-5 animate-spin mr-2"></i> Se salvează...`;
                    lucide.createIcons();

                    const newTemplates = {
                        notification: document.getElementById('template-notification').value,
                        lastSession: document.getElementById('template-lastSession').value,
                        newSubscription: document.getElementById('template-newSubscription').value,
                        cancelByInstructor: document.getElementById('template-cancelByInstructor').value,
                        cancelByClient: document.getElementById('template-cancelByClient').value,
                    };

                    try {
                        await firestoreApi.saveMessageTemplates(newTemplates);
                        state.messageTemplates = newTemplates;
                        renderNotification('Șabloanele de mesaje au fost salvate cu succes!', 'success');
                    } catch (err) {
                        renderNotification(`Eroare la salvarea șabloanelor: ${err.message}`, 'error');
                    } finally {
                        button.disabled = false;
                        button.textContent = 'Salvează Mesajele';
                    }
                });

                document.getElementById('save-stripe-key-btn')?.addEventListener('click', async () => {
                    const input = document.getElementById('stripe-key-input');
                    const key = input.value.trim();
                    if (!key) {
                        renderNotification("Te rugăm să introduci o cheie.", "error");
                        return;
                    }
                    try {
                        await firestoreApi.saveApiKey('stripeRestrictedKey', key);
                        renderNotification('Cheia Stripe a fost salvată cu succes.', 'success');
                        input.value = '';
                    } catch (err) {
                        renderNotification(`Eroare la salvarea cheii: ${err.message}`, 'error');
                    }
                });

                // Event listeners for double booking rules
                document.querySelectorAll('.day-enable-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const day = e.target.dataset.day;
                        const timeInputs = document.querySelectorAll(`.time-input[data-day="${day}"]`);
                        timeInputs.forEach(input => input.disabled = !e.target.checked);
                    });
                });

                document.getElementById('save-booking-rules-btn')?.addEventListener('click', async () => {
                    const button = document.getElementById('save-booking-rules-btn');
                    button.disabled = true;
                    button.innerHTML = `<i data-lucide="loader-2" class="h-5 w-5 animate-spin mr-2"></i> Se salvează...`;
                    lucide.createIcons();

                    const newRules = {};
                    document.querySelectorAll('.day-enable-checkbox').forEach(checkbox => {
                        const day = checkbox.dataset.day;
                        const enabled = checkbox.checked;
                        const startTime = document.querySelector(`.time-input[data-day="${day}"][data-type="start"]`).value;
                        const endTime = document.querySelector(`.time-input[data-day="${day}"][data-type="end"]`).value;
                        newRules[day] = {
                            enabled,
                            startTime: parseInt(startTime, 10),
                            endTime: parseInt(endTime, 10)
                        };
                    });

                    try {
                        await firestoreApi.saveDoubleBookingRules(newRules);
                        state.doubleBookingRules = newRules;
                        renderNotification('Regulile de rezervare dublă au fost salvate!', 'success');
                    } catch (err) {
                        renderNotification(`Eroare la salvarea regulilor: ${err.message}`, 'error');
                    } finally {
                        button.disabled = false;
                        button.textContent = 'Salvează Regulile';
                    }
                });

                // Event listeners for working hours
                document.querySelectorAll('.wh-day-enable-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const day = e.target.dataset.day;
                        const timeInputs = document.querySelectorAll(`.wh-time-input[data-day="${day}"]`);
                        timeInputs.forEach(input => input.disabled = !e.target.checked);
                    });
                });

                document.getElementById('save-working-hours-btn')?.addEventListener('click', async () => {
                    const button = document.getElementById('save-working-hours-btn');
                    button.disabled = true;
                    button.innerHTML = `<i data-lucide="loader-2" class="h-5 w-5 animate-spin mr-2"></i> Se salvează...`;
                    lucide.createIcons();

                    const newHours = {};
                    document.querySelectorAll('.wh-day-enable-checkbox').forEach(checkbox => {
                        const day = checkbox.dataset.day;
                        const enabled = checkbox.checked;
                        const startTime = document.querySelector(`.wh-time-input[data-day="${day}"][data-type="start"]`).value;
                        const endTime = document.querySelector(`.wh-time-input[data-day="${day}"][data-type="end"]`).value;
                        newHours[day] = {
                            enabled,
                            startTime: parseInt(startTime, 10),
                            endTime: parseInt(endTime, 10)
                        };
                    });

                    try {
                        await firestoreApi.saveWorkingHours(newHours);
                        state.workingHours = newHours;
                        renderNotification('Programul de lucru a fost salvat!', 'success');
                    } catch (err) {
                        renderNotification(`Eroare la salvarea programului: ${err.message}`, 'error');
                    } finally {
                        button.disabled = false;
                        button.textContent = 'Salvează Programul';
                    }
                });
            };

            const attachTimeSlotEventListeners = () => {
                document.querySelectorAll('.time-slot-btn').forEach(button => {
                    if (button.disabled) return;
                    button.addEventListener('click', () => {
                        const { startTime, endTime } = button.dataset;
                        showCreateEventModal(startTime, endTime);
                    });
                });
            };

            const updateUI = () => {
                const tabConfig = {
                    dashboard: { name: 'Dashboard', icon: 'layout-dashboard' },
                    add: { name: 'Adaugă Programare', icon: 'calendar-plus' },
                    today: { name: 'Astăzi', icon: 'calendar-check' },
                    tomorrow: { name: 'Mâine', icon: 'calendar-clock' },
                    all: { name: 'Toți Clienții', icon: 'users' },
                    instructors: { name: 'Instructori', icon: 'user-cog' },
                    financials: { name: 'Financiar', icon: 'credit-card' },
                    reports: { name: 'Rapoarte', icon: 'bar-chart-3' },
                    timesheet: { name: 'Pontaj', icon: 'clock' },
                    settings: { name: 'Setări', icon: 'settings' }
                };

                dom.tabButtons.forEach(btn => {
                    const tab = btn.dataset.tab;
                    const config = tabConfig[tab];

                    btn.innerHTML = `<i data-lucide="${config.icon}" class="h-4 w-4 mr-2"></i><span>${config.name}</span>`;

                    const isSelected = tab === state.activeTab;
                    const baseClasses = 'tab-button flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800';
                    const selectedClasses = 'bg-blue-600 text-white shadow-md';
                    const unselectedClasses = 'bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white';

                    btn.className = `${baseClasses} ${isSelected ? selectedClasses : unselectedClasses}`;
                });

                const isClientTab = ['today', 'tomorrow', 'all'].includes(state.activeTab);
                document.querySelectorAll('.filter-control').forEach(el => el.style.display = isClientTab ? 'flex' : 'none');

                dom.incrementAllBtn.style.display = state.activeTab === 'tomorrow' ? 'block' : 'none';

                const logSessionsBtn = document.getElementById('logTodaysSessionsBtn');
                if (logSessionsBtn) {
                    logSessionsBtn.style.display = state.activeTab === 'today' ? 'block' : 'none';
                }

                lucide.createIcons();
            };

            // --- MODAL FUNCTIONS ---
            const showModal = (modalElement) => {
                modalElement.classList.remove('hidden');
                setTimeout(() => {
                    modalElement.classList.remove('opacity-0');
                    modalElement.querySelector('.modal-content').classList.remove('scale-95');
                }, 10);
            };

            const hideModal = (modalElement) => {
                modalElement.classList.add('opacity-0');
                modalElement.querySelector('.modal-content').classList.add('scale-95');
                setTimeout(() => {
                    modalElement.classList.add('hidden');
                    if (modalElement.id === 'cancel-modal') {
                        state.cancellationContext = null;
                    }
                    if (modalElement.id === 'cash-payment-modal') {
                        state.cashPaymentContext = null;
                    }
                }, 300);
            };

            const showCreateEventModal = (startTime, endTime) => {
                dom.createEventForm.reset(); // Clear previous inputs

                const start = new Date(startTime);
                const end = new Date(endTime);
                document.getElementById('event-start-time').value = startTime;
                document.getElementById('event-end-time').value = endTime;
                document.getElementById('event-time-display').value =
                    `${start.toLocaleDateString('ro-RO', { weekday: 'long', day: 'numeric', month: 'long' })} la ${start.toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' })}`;

                const disciplineSelect = document.getElementById('event-discipline');
                disciplineSelect.innerHTML = state.disciplinesForBooking
                    .map(d => `<option value="${d}">${d}</option>`)
                    .join('');

                showModal(dom.createEventModal);
            };

            const showCashPaymentModal = (name, eventId) => {
                dom.cashPaymentForm.reset();
                document.getElementById('cash-client-name').value = name;
                document.getElementById('cash-event-id').value = eventId;
                document.getElementById('cash-client-name-display').value = name;
                showModal(dom.cashPaymentModal);
            };

            async function handleCreateEventSubmit(e) {
                e.preventDefault();
                const button = dom.submitEventBtn;
                button.disabled = true;
                button.innerHTML = `<i data-lucide="loader-2" class="h-5 w-5 mr-2 animate-spin"></i> Se creează...`;
                lucide.createIcons();

                try {
                    const name = document.getElementById('client-name').value.trim();
                    const phone = document.getElementById('client-phone').value.trim();
                    const email = document.getElementById('client-email').value.trim();
                    const discipline = document.getElementById('event-discipline').value;
                    const startTime = document.getElementById('event-start-time').value;
                    const endTime = document.getElementById('event-end-time').value;

                    if (!name || !phone || !email || !discipline) {
                        throw new Error("Toate câmpurile sunt obligatorii.");
                    }

                    const cancellationPolicy = `\n\nCancellation policy\nVa reamintim ca sedintele anulate cu mai putin de 48 de ore inainte de programare vor fi considerate ca fiind efectuate iar pretul lor nu va fi returnat.`;
                    const eventLocation = "Asorte Music Academy, Strada Nucetului 25c, București 040696";

                    const eventData = {
                        summary: `${name} - ${discipline} - Sedinta de proba`,
                        description: `Telefon: ${phone}\nEmail: ${email}${cancellationPolicy}`,
                        location: eventLocation,
                        start: { dateTime: startTime, timeZone: 'Europe/Bucharest' },
                        end: { dateTime: endTime, timeZone: 'Europe/Bucharest' },
                        attendees: [{ email: email }],
                        colorId: '3' // Purple
                    };

                    await api.createEvent(eventData);

                    await firestoreApi.saveClientData(name, { name, phone, email, discipline, subscription: '4', assignedInstructor: '' });

                    renderNotification(`Programarea pentru ${name} a fost creată cu succes!`, 'success');
                    hideModal(dom.createEventModal);
                    renderAvailabilitySchedule(); // Refresh the view

                } catch (err) {
                    renderNotification(`Eroare la crearea evenimentului: ${err.message}`, 'error');
                } finally {
                    button.disabled = false;
                    button.innerHTML = `<i data-lucide="plus-circle" class="h-5 w-5 mr-2"></i> Creează Eveniment`;
                    lucide.createIcons();
                }
            }

            async function handleCashPaymentSubmit(e) {
                e.preventDefault();
                const button = dom.submitCashPaymentBtn;
                button.disabled = true;
                button.innerHTML = `<i data-lucide="loader-2" class="h-5 w-5 mr-2 animate-spin"></i> Se salvează...`;
                lucide.createIcons();

                const clientName = document.getElementById('cash-client-name').value;
                const eventId = document.getElementById('cash-event-id').value;
                const amount = document.getElementById('cash-amount').value;

                try {
                    if (!amount || parseFloat(amount) <= 0) {
                        throw new Error("Suma trebuie să fie un număr pozitiv.");
                    }

                    // 1. Log payment to Firestore
                    const paymentDate = new Date().toISOString().split('T')[0];
                    await firestoreApi.logCashPayment(clientName, amount, paymentDate);

                    // 2. Update Google Calendar event description
                    const event = await api.getEventById(eventId);
                    const todayStr = new Date().toLocaleDateString('ro-RO');
                    const newPaymentLine = `Last Payment: ${todayStr} - Cash`;
                    let newDescription = event.description || '';
                    if (newDescription.includes('Last Payment:')) {
                        newDescription = newDescription.replace(/Last Payment: .*/g, newPaymentLine);
                    } else {
                        newDescription = `${newDescription}\n${newPaymentLine}`.trim();
                    }
                    await api.updateEventDescription(eventId, newDescription);

                    renderNotification(`Plata cash de ${amount} RON pentru ${clientName} a fost înregistrată.`, 'success');
                    hideModal(dom.cashPaymentModal);
                    handleTabChange(); // Refresh the view to show updated "Last Payment"

                } catch (err) {
                    renderNotification(`Eroare la înregistrarea plății: ${err.message}`, 'error');
                } finally {
                    button.disabled = false;
                    button.innerHTML = `<i data-lucide="save" class="h-5 w-5 mr-2"></i> Salvează Plata`;
                    lucide.createIcons();
                }
            }

            async function handleCancelByInstructor() {
                if (!state.cancellationContext) return;
                const { eventId, name, discipline, phone, originalButton } = state.cancellationContext;

                hideModal(dom.cancelModal);
                originalButton.innerHTML = `<i data-lucide="loader-2" class="h-4 w-4 animate-spin"></i>`;
                originalButton.disabled = true;
                lucide.createIcons();

                try {
                    const clientDetails = state.clients[name];
                    const formattedTime = clientDetails.startTime ? new Date(clientDetails.startTime).toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' }) : '';
                    const dayText = state.activeTab === 'today' ? 'astăzi' : 'mâine';
                    const formattedDate = clientDetails.startTime ? new Date(clientDetails.startTime).toLocaleDateString('ro-RO', { weekday: 'long', day: 'numeric', month: 'long' }) : dayText;

                    const newSummary = `${name} - ${discipline}`;
                    await api.updateEventSummary(eventId, newSummary);
                    await api.cancelEvent(eventId);

                    renderNotification(`Evenimentul pentru ${name} a fost anulat de instructor. Numărul sesiunii a fost eliminat.`, 'success');
                    document.getElementById(`client-${eventId}`)?.remove();

                    const messageData = { name, discipline, date: formattedDate, time: formattedTime };
                    const message = replacePlaceholders(state.messageTemplates.cancelByInstructor, messageData);

                    const link = getWhatsAppLink(phone, message);
                    if (link) {
                        window.open(link, '_blank');
                    }
                } catch (err) {
                    renderNotification(`Eroare la anularea evenimentului: ${err.message}`, 'error');
                    originalButton.innerHTML = `<i data-lucide="x-circle" class="h-4 w-4 mr-1.5"></i><span>Anulează</span>`;
                    lucide.createIcons();
                    originalButton.disabled = false;
                }
            }

            async function handleCancelByClient() {
                if (!state.cancellationContext) return;
                const { eventId, name, phone, discipline, originalButton } = state.cancellationContext;

                hideModal(dom.cancelModal);
                originalButton.innerHTML = `<i data-lucide="loader-2" class="h-4 w-4 animate-spin"></i>`;
                originalButton.disabled = true;
                lucide.createIcons();

                try {
                    const clientDetails = state.clients[name];
                    const formattedTime = clientDetails.startTime ? new Date(clientDetails.startTime).toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' }) : '';
                    const dayText = state.activeTab === 'today' ? 'astăzi' : 'mâine';
                    const formattedDate = clientDetails.startTime ? new Date(clientDetails.startTime).toLocaleDateString('ro-RO', { weekday: 'long', day: 'numeric', month: 'long' }) : dayText;

                    await api.cancelEvent(eventId);
                    renderNotification(`Evenimentul pentru ${name} a fost anulat de client.`, 'success');
                    document.getElementById(`client-${eventId}`)?.remove();

                    const messageData = { name, discipline, date: formattedDate, time: formattedTime };
                    const message = replacePlaceholders(state.messageTemplates.cancelByClient, messageData);

                    const link = getWhatsAppLink(phone, message);
                    if (link) window.open(link, '_blank');
                } catch (err) {
                    renderNotification(`Eroare la anularea evenimentului: ${err.message}`, 'error');
                    originalButton.innerHTML = `<i data-lucide="x-circle" class="h-4 w-4 mr-1.5"></i><span>Anulează</span>`;
                    lucide.createIcons();
                    originalButton.disabled = false;
                }
            }

            // --- AUTH & INITIALIZATION ---
            function handleManualTokenSubmit() {
                const manualAccessTokenInput = document.getElementById('manualAccessToken');
                const token = manualAccessTokenInput.value.trim();
                if (!token) {
                    renderNotification('Te rugăm să introduci un token de acces valid.', 'error');
                    return;
                }
                state.accessToken = token;
                renderNotification('Token de acces acceptat. Se inițializează aplicația...', 'success');
                document.getElementById('auth-section').style.display = 'none';
                document.getElementById('config-hr').style.display = 'block';
                document.getElementById('main-config-controls').style.display = 'block';
                initializeAppLogic();
            }

            window.onload = () => {
                lucide.createIcons();
                updateUI();

                const submitTokenBtn = document.getElementById('submitTokenBtn');
                if (submitTokenBtn) {
                    submitTokenBtn.addEventListener('click', handleManualTokenSubmit);
                }

                const testingModeToggle = document.getElementById('testing-mode-toggle');
                const manualAuthSection = document.getElementById('manual-auth-section');
                if (testingModeToggle && manualAuthSection) {
                    testingModeToggle.addEventListener('click', (e) => {
                        e.preventDefault();
                        const isHidden = manualAuthSection.style.display === 'none';
                        manualAuthSection.style.display = isHidden ? 'block' : 'none';
                        testingModeToggle.textContent = isHidden ? 'Ascunde Modul de Testare' : 'Intră în Modul de Testare';
                    });
                }

                let tokenClient;
                function handleAuthClick() {
                    if (tokenClient) {
                        tokenClient.requestAccessToken();
                    } else {
                        renderNotification('Clientul de autentificare Google nu este inițializat. Te rugăm să aștepți sau să reîmprospătezi.', 'error');
                    }
                }

                const authBtn = document.getElementById('authBtn');
                if (authBtn) {
                    authBtn.addEventListener('click', handleAuthClick);
                }

                try {
                    tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: GOOGLE_CLIENT_ID,
                        scope: SCOPES,
                        callback: async (tokenResponse) => {
                            if (tokenResponse.error) {
                                renderNotification(`Eroare de autorizare: ${tokenResponse.error_description || tokenResponse.error}`, 'error');
                                return;
                            }
                            state.accessToken = tokenResponse.access_token;
                            renderNotification('Autorizare reușită. Se inițializează aplicația...', 'success');
                            document.getElementById('auth-section').style.display = 'none';
                            document.getElementById('config-hr').style.display = 'block';
                            document.getElementById('main-config-controls').style.display = 'block';
                            initializeAppLogic();
                        },
                    });
                } catch (error) {
                    console.error("Google Auth initialization failed:", error);
                    renderNotification("Nu s-a putut încărca biblioteca Google Sign-In. Verifică conexiunea și reîmprospătează pagina.", "error");
                }
            };

            // --- Helper Functions ---
            const getClientFinancialData = async (clientNames) => {
                if (clientNames.length === 0) return {};

                // 1. Fetch basic client info from Firestore (subscription type, email, etc.)
                const clientDataMap = {};
                const firestorePromises = clientNames.map(name => firestoreApi.getClientData(name));
                const firestoreResults = await Promise.all(firestorePromises);
                firestoreResults.forEach(data => {
                    if (data.name) {
                        clientDataMap[data.name] = {
                            subscription: data.subscription || '4',
                            email: data.email || null,
                            lastPaymentAmount: 0 // Default value
                        };
                    }
                });

                let allPayments = [];

                // 2. Fetch Stripe Payments from Cloud Function
                try {
                    const functions = getFunctions(app);
                    const getStripeFinancials = httpsCallable(functions, 'getStripeFinancials');
                    const ninetyDaysAgo = new Date();
                    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);

                    const stripeResult = await getStripeFinancials({
                        startDate: ninetyDaysAgo.toISOString(),
                        endDate: new Date().toISOString()
                    });

                    // Standardize Stripe payment objects
                    const stripePayments = (stripeResult.data.payments || []).map(p => ({
                        clientName: p.customer,
                        email: p.email,
                        date: new Date(p.date),
                        amount: p.net, // Use net amount for commission
                        method: 'Stripe'
                    }));
                    allPayments.push(...stripePayments);
                } catch (error) {
                    console.error("Could not fetch Stripe payments for timesheet:", error);
                }

                // 3. Fetch Cash Payments from Firestore
                try {
                    const cashPaymentsSnapshot = await getDocs(collection(db, "payments"));
                    cashPaymentsSnapshot.forEach(doc => {
                        const data = doc.data();
                        // Standardize cash payment objects
                        allPayments.push({
                            clientName: data.clientName,
                            email: null, // Cash payments don't have an email stored
                            date: new Date(data.created), // Use 'created' timestamp for accurate sorting
                            amount: data.amount,
                            method: 'Cash'
                        });
                    });
                } catch (error) {
                    console.error("Could not fetch cash payments for timesheet:", error);
                }

                // 4. For each client, find their single most recent payment from the combined list
                clientNames.forEach(name => {
                    const clientInfo = clientDataMap[name];
                    if (clientInfo) {
                        const clientNameLower = name.toLowerCase();
                        const clientEmailLower = clientInfo.email ? clientInfo.email.toLowerCase() : null;

                        const relevantPayments = allPayments.filter(p =>
                            (p.clientName?.toLowerCase() === clientNameLower) ||
                            (clientEmailLower && p.email?.toLowerCase() === clientEmailLower)
                        ).sort((a, b) => b.date - a.date); // Sort all payments for the client, descending by date

                        if (relevantPayments.length > 0) {
                            // The first payment in the sorted list is the most recent one
                            clientDataMap[name].lastPaymentAmount = relevantPayments[0].amount;
                        }
                    }
                });

                return clientDataMap;
            };
            const getWhatsAppLink = (phone, text = '') => {
                if (!phone) return null;
                let cleanPhoneNumber = phone.trim().replace(/[\s-()]/g, '');
                if (cleanPhoneNumber.startsWith('+')) {
                    cleanPhoneNumber = cleanPhoneNumber.substring(1);
                }
                else if (cleanPhoneNumber.startsWith('0')) {
                    cleanPhoneNumber = '40' + cleanPhoneNumber.substring(1);
                }
                else if (!cleanPhoneNumber.startsWith('40') && !cleanPhoneNumber.startsWith('380')) {
                    cleanPhoneNumber = '40' + cleanPhoneNumber;
                }
                let link = `https://wa.me/${cleanPhoneNumber}`;
                if (text) link += `?text=${encodeURIComponent(text)}`;
                return link;
            };
            // NEW HELPER FUNCTION
            const getGoogleCalendarEditUrl = (eventId) => {
                if (!eventId || !state.calendarId) return '#';
                const eventIdentifier = btoa(`${eventId} ${state.calendarId}`).replace(/=/g, '');
                return `https://calendar.google.com/calendar/r/eventedit/${eventIdentifier}`;
            };

            const isPaymentOverdue = (paymentDateStr) => {
                if (!paymentDateStr || paymentDateStr === "Nici o plată încă") return false;

                const datePart = paymentDateStr.split(' - ')[0];
                const parts = datePart.split('.');
                if (parts.length !== 3) return false;

                const paymentDate = new Date(parts[2], parts[1] - 1, parts[0]);

                if (isNaN(paymentDate.getTime())) return false;

                const today = new Date();
                today.setHours(0, 0, 0, 0);

                const timeDifference = today.getTime() - paymentDate.getTime();
                const daysDifference = timeDifference / (1000 * 3600 * 24);

                return daysDifference > 30;
            };

            const processCalendarItems = async (items) => {
                const processedClients = {};
                if (!items) return processedClients;

                const clientsCollection = collection(db, "clients");
                const snapshot = await getDocs(clientsCollection);
                const existingClientsMap = new Map();
                snapshot.forEach(doc => {
                    existingClientsMap.set(doc.id, doc.data());
                });

                const filteredItems = items.filter(event => event.status !== 'cancelled' && !(event.organizer && event.attendees && event.attendees.find(a => a.email === event.organizer.email)?.responseStatus === 'declined'));

                for (const event of filteredItems) {
                    if (!event.summary) continue;
                    const parts = event.summary.split(' - ').map(p => p.trim());
                    if (parts.length < 2) continue;

                    const name = parts[0];
                    const discipline = parts[1];
                    let sessionNumber = 0;

                    if (parts.length >= 3) {
                        const sessionPart = parts[2];
                        const parsedNumber = parseInt(sessionPart.toLowerCase().replace('sedinta', '').replace('#', ''), 10);
                        if (!isNaN(parsedNumber)) {
                            sessionNumber = parsedNumber;
                        }
                    }

                    let phone = null;
                    if (event.description) {
                        const phoneMatch = event.description.match(/\+?\d[\d\s-()]{8,15}/);
                        if (phoneMatch) phone = phoneMatch[0];
                    }
                    const studentEmail = event.attendees?.find(a => !a.organizer && a.email !== event.organizer?.email)?.email;

                    if (name && discipline && phone) {
                        const sanitizedName = sanitizeForFirestoreId(name);
                        const existingData = existingClientsMap.get(sanitizedName);
                        if (!existingData || existingData.discipline !== discipline || existingData.phone !== phone) {
                            console.log(`Syncing data for ${sanitizedName}: New or changed.`);
                            firestoreApi.saveClientData(name, {
                                name: name,
                                discipline: discipline,
                                phone: phone
                            }).catch(err => console.error("Failed to save client info to Firestore:", err));
                        }
                    }

                    processedClients[name] = {
                        eventId: event.id, discipline, sessionNumber, studentEmail,
                        startTime: event.start?.dateTime,
                        phone: phone || processedClients[name]?.phone,
                        lastPayment: null, // This will be populated later
                    };
                }
                return processedClients;
            };

            async function fetchAndMergeLastPayments(clients, clientFirebaseData) {
                if (Object.keys(clients).length === 0) return;

                console.log("Fetching last payments for all visible clients...");
                const clientNames = Object.keys(clients);
                const lastPayments = {};

                // Create a map for client emails for easier lookup
                const clientEmailMap = {};
                clientNames.forEach(name => {
                    const firebaseData = clientFirebaseData[name];
                    const calendarData = clients[name];
                    // Prioritize email from Firestore, fallback to email from Calendar event
                    clientEmailMap[name] = firebaseData?.email || calendarData?.studentEmail || null;
                });

                // 1. Fetch Stripe Payments
                try {
                    const functions = getFunctions(app);
                    const getStripeFinancials = httpsCallable(functions, 'getStripeFinancials');
                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setDate(endDate.getDate() - 365); // Look back one year

                    const stripeResult = await getStripeFinancials({
                        startDate: startDate.toISOString(),
                        endDate: endDate.toISOString()
                    });
                    const stripePayments = stripeResult.data.payments || [];

                    // Iterate through clients and find their latest stripe payment
                    clientNames.forEach(name => {
                        const clientEmail = clientEmailMap[name]?.toLowerCase();
                        const clientNameLower = name.toLowerCase();

                        const relevantPayments = stripePayments.filter(p => {
                            const paymentCustomerLower = p.customer?.toLowerCase();
                            const paymentEmailLower = p.email?.toLowerCase();

                            return (paymentCustomerLower && paymentCustomerLower === clientNameLower) ||
                                (clientEmail && paymentEmailLower && paymentEmailLower === clientEmail);
                        });

                        if (relevantPayments.length > 0) {
                            // Find the most recent payment among the relevant ones
                            relevantPayments.sort((a, b) => new Date(b.date) - new Date(a.date));
                            const latestPayment = relevantPayments[0];
                            const paymentDate = new Date(latestPayment.date);

                            lastPayments[name] = {
                                date: paymentDate,
                                text: `${paymentDate.toLocaleDateString('ro-RO')} - Stripe`
                            };
                        }
                    });

                } catch (error) {
                    console.error("Could not fetch Stripe payments:", error);
                }

                // 2. Fetch Cash Payments from Firestore and potentially override Stripe if newer
                try {
                    const cashPaymentsSnapshot = await getDocs(collection(db, "payments"));
                    cashPaymentsSnapshot.forEach(doc => {
                        const data = doc.data();
                        const clientName = data.clientName;
                        if (clientNames.includes(clientName)) { // Only process for visible clients
                            const paymentDate = new Date(data.created);
                            if (!lastPayments[clientName] || paymentDate > lastPayments[clientName].date) {
                                lastPayments[clientName] = {
                                    date: paymentDate,
                                    text: `${new Date(data.date).toLocaleDateString('ro-RO')} - Cash`
                                };
                            }
                        }
                    });
                } catch (error) {
                    console.error("Could not fetch cash payments:", error);
                }

                // 3. Merge into state.clients
                clientNames.forEach(name => {
                    if (clients[name]) {
                        clients[name].lastPayment = lastPayments[name] ? lastPayments[name].text : "Nici o plată încă";
                    }
                });
                console.log("Finished merging last payments.");
            }


            // --- Reports Logic ---
            const attachReportsEventListeners = () => {
                document.getElementById('generate-attendance-report')?.addEventListener('click', generateAttendanceReport);
                document.getElementById('generate-retention-report')?.addEventListener('click', generateClientRetentionReport);
            };

            const generateAttendanceReport = async () => {
                const resultsContainer = document.getElementById('attendance-report-results');
                const startDateStr = document.getElementById('attendance-start-date').value;
                const endDateStr = document.getElementById('attendance-end-date').value;
                if (!startDateStr || !endDateStr) {
                    renderNotification("Te rugăm să selectezi un interval de date.", "error");
                    return;
                }

                resultsContainer.innerHTML = `<div class="flex items-center justify-center p-5"><i data-lucide="loader-2" class="h-6 w-6 animate-spin text-blue-400"></i><span class="ml-3">Se generează raportul de prezență...</span></div>`;
                lucide.createIcons();

                try {
                    const startDate = new Date(startDateStr);
                    startDate.setHours(0, 0, 0, 0);
                    const endDate = new Date(endDateStr);
                    endDate.setHours(23, 59, 59, 999);

                    const events = await api.getEventsForDateRange(startDate, endDate, true); // showDeleted = true

                    const clientStats = {};

                    for (const event of events) {
                        if (!event.summary) continue;
                        const parts = event.summary.split(' - ').map(p => p.trim());
                        if (parts.length < 2) continue;
                        const name = parts[0];

                        if (!clientStats[name]) {
                            clientStats[name] = { name, attended: 0, cancelledByClient: 0, cancelledByInstructor: 0, total: 0 };
                        }

                        clientStats[name].total++;

                        const organizer = event.attendees?.find(a => a.organizer);
                        const isDeclinedByOrganizer = organizer?.responseStatus === 'declined';

                        if (event.status === 'cancelled' || isDeclinedByOrganizer) {
                            clientStats[name].cancelledByClient++;
                        } else {
                            clientStats[name].attended++;
                        }
                    }

                    const reportData = Object.values(clientStats).sort((a, b) => a.name.localeCompare(b.name));

                    if (reportData.length === 0) {
                        resultsContainer.innerHTML = `<p class="text-center text-gray-400 py-4">Nu s-au găsit date pentru intervalul selectat.</p>`;
                        return;
                    }

                    const reportHTML = reportData.map(client => {
                        const attendanceRate = client.total > 0 ? (client.attended / client.total) * 100 : 0;
                        let progressBarColor = 'bg-green-500';
                        if (attendanceRate < 80) progressBarColor = 'bg-yellow-500';
                        if (attendanceRate < 50) progressBarColor = 'bg-red-500';

                        return `
                            <div class="bg-gray-700/50 rounded-lg p-4 mb-3 transition-all hover:bg-gray-700">
                                <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between">
                                    <div class="mb-3 sm:mb-0 min-w-0">
                                        <p class="text-lg font-bold text-white truncate" title="${client.name}">${client.name}</p>
                                    </div>
                                    <div class="flex items-center gap-4 text-center">
                                        <div>
                                            <p class="text-xs text-gray-400">Prezent</p>
                                            <p class="text-xl font-semibold text-green-400">${client.attended}</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-400">Anulat</p>
                                            <p class="text-xl font-semibold text-red-400">${client.cancelledByClient}</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-400">Total</p>
                                            <p class="text-xl font-semibold text-gray-300">${client.total}</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="mt-4">
                                    <div class="flex justify-between items-center mb-1">
                                        <span class="text-xs font-medium text-gray-400">Rată Prezență</span>
                                        <span class="text-sm font-bold ${progressBarColor.replace('bg-', 'text-')}">${attendanceRate.toFixed(0)}%</span>
                                    </div>
                                    <div class="w-full bg-gray-600 rounded-full h-2.5">
                                        <div class="${progressBarColor} h-2.5 rounded-full" style="width: ${attendanceRate}%"></div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    resultsContainer.innerHTML = `<div class="space-y-3">${reportHTML}</div>`;
                    document.getElementById('export-attendance').onclick = () => exportToCSV(reportData, 'raport_prezenta');

                } catch (err) {
                    resultsContainer.innerHTML = `<p class="text-red-400 p-4">Eroare la generarea raportului: ${err.message}</p>`;
                }
            };

            const generateClientRetentionReport = async () => {
                const resultsContainer = document.getElementById('retention-report-results');
                resultsContainer.innerHTML = `<div class="flex items-center justify-center p-5"><i data-lucide="loader-2" class="h-6 w-6 animate-spin text-blue-400"></i><span class="ml-3">Se generează raportul de retenție...</span></div>`;
                lucide.createIcons();

                try {
                    const ninetyDaysAgo = new Date();
                    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
                    const today = new Date();

                    const events = await api.getEventsForDateRange(ninetyDaysAgo, today);

                    const trialSessions = events.filter(e => e.summary?.toLowerCase().includes('sedinta de proba'));
                    const regularSessions = events.filter(e => e.summary?.match(/sedinta \d+/i));

                    let convertedCount = 0;
                    const trialClients = new Set(trialSessions.map(e => e.summary.split(' - ')[0]));

                    trialClients.forEach(clientName => {
                        if (regularSessions.some(e => e.summary.startsWith(clientName))) {
                            convertedCount++;
                        }
                    });

                    const conversionRate = trialClients.size > 0 ? (convertedCount / trialClients.size) * 100 : 0;

                    const reportData = [
                        { metric: 'Ședințe de probă', value: trialClients.size },
                        { metric: 'Clienți convertiți', value: convertedCount },
                        { metric: 'Rata de conversie', value: `${conversionRate.toFixed(1)}%` },
                    ];

                    const tableHTML = `
                        <table class="report-table min-w-full divide-y divide-gray-600">
                            <thead class="bg-gray-700">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Metrică</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Valoare</th>
                                </tr>
                            </thead>
                            <tbody class="bg-gray-800 divide-y divide-gray-700">
                                ${reportData.map(item => `
                                    <tr>
                                        <td class="px-4 py-4 whitespace-nowrap text-sm font-medium text-white">${item.metric}</td>
                                        <td class="px-4 py-4 whitespace-nowrap text-sm text-gray-300">${item.value}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                    resultsContainer.innerHTML = tableHTML;
                    document.getElementById('export-retention').onclick = () => exportToCSV(reportData, 'raport_retentie');

                } catch (err) {
                    resultsContainer.innerHTML = `<p class="text-red-400 p-4">Eroare la generarea raportului: ${err.message}</p>`;
                }
            };

            const exportToCSV = (data, filename) => {
                if (!data || data.length === 0) {
                    renderNotification("Nu există date de exportat.", "error");
                    return;
                }
                const headers = Object.keys(data[0]);
                const csvRows = [
                    headers.join(','),
                    ...data.map(row =>
                        headers.map(header =>
                            JSON.stringify(row[header], (key, value) => value === undefined ? '' : value)
                        ).join(',')
                    )
                ];

                const csvString = csvRows.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${filename}_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const attachFinancialsEventListeners = () => {
                document.getElementById('generate-payments-list')?.addEventListener('click', fetchAndDisplayFinancials);
                document.getElementById('financial-client-search')?.addEventListener('input', debounce(filterAndRenderPayments, 300));

                const resultsContainer = document.getElementById('payments-list-results');
                if (resultsContainer) {
                    resultsContainer.addEventListener('click', async (e) => {
                        const deleteButton = e.target.closest('.delete-payment-btn');
                        if (deleteButton) {
                            const paymentId = deleteButton.dataset.id;
                            if (!paymentId) return;

                            deleteButton.innerHTML = `<i data-lucide="loader-2" class="h-4 w-4 animate-spin"></i>`;
                            lucide.createIcons();
                            deleteButton.disabled = true;

                            try {
                                await firestoreApi.deleteCashPayment(paymentId);
                                state.financials.allPayments = state.financials.allPayments.filter(p => p.id !== paymentId);
                                filterAndRenderPayments();
                                renderNotification('Plata cash a fost ștearsă.', 'success');
                            } catch (err) {
                                renderNotification(`Eroare la ștergerea plății: ${err.message}`, 'error');
                            }
                        }
                    });
                }

                // Initial load
                fetchAndDisplayFinancials();
            };

            const fetchAndDisplayFinancials = async () => {
                const resultsContainer = document.getElementById('payments-list-results');
                const startDateStr = document.getElementById('payments-start-date').value;
                const endDateStr = document.getElementById('payments-end-date').value;

                if (!startDateStr || !endDateStr) {
                    renderNotification("Te rugăm să selectezi un interval de date valid.", "error");
                    return;
                }

                resultsContainer.innerHTML = `<div class="flex items-center justify-center p-5"><i data-lucide="loader-2" class="h-6 w-6 animate-spin text-blue-400"></i><span class="ml-3">Se încarcă datele financiare...</span></div>`;
                lucide.createIcons();

                try {
                    // Fetch Stripe payments from Cloud Function
                    const functions = getFunctions(app);
                    const getStripeFinancials = httpsCallable(functions, 'getStripeFinancials');
                    const stripeResult = await getStripeFinancials({
                        startDate: new Date(startDateStr).toISOString(),
                        endDate: new Date(endDateStr).toISOString()
                    });
                    const stripePayments = stripeResult.data.payments || [];

                    // Fetch cash payments from Firestore
                    const cashPaymentsSnapshot = await getDocs(collection(db, "payments"));
                    const cashPayments = [];
                    cashPaymentsSnapshot.forEach(doc => {
                        const data = doc.data();
                        const paymentDate = new Date(data.date);
                        const rangeStart = new Date(startDateStr);
                        const rangeEnd = new Date(endDateStr);
                        if (paymentDate >= rangeStart && paymentDate <= rangeEnd) {
                            cashPayments.push({
                                id: doc.id, // Store document ID for deletion
                                customer: data.clientName,
                                email: 'N/A',
                                amount: data.amount,
                                net: data.amount,
                                description: data.description || 'Plată cash',
                                date: data.created,
                                method: 'Cash'
                            });
                        }
                    });

                    // Combine and sort
                    const combinedPayments = [...stripePayments, ...cashPayments];
                    combinedPayments.sort((a, b) => new Date(b.date) - new Date(a.date));
                    state.financials.allPayments = combinedPayments;

                    // Update stats based on the full dataset for the date range
                    const revenueStatEl = document.getElementById('revenue-stat');
                    const avgSpendStatEl = document.getElementById('avg-spend-stat');

                    const totalRevenue = state.financials.allPayments.reduce((sum, p) => sum + p.net, 0);
                    const totalGross = state.financials.allPayments.reduce((sum, p) => sum + p.amount, 0);
                    const uniqueCustomers = new Set(state.financials.allPayments.map(p => p.customer)).size;
                    const avgSpend = uniqueCustomers > 0 ? totalGross / uniqueCustomers : 0;

                    revenueStatEl.textContent = `${totalRevenue.toFixed(2)} RON`;
                    avgSpendStatEl.textContent = `${avgSpend.toFixed(2)} RON`;

                    // Render the list
                    filterAndRenderPayments();

                } catch (error) {
                    console.error("Error fetching financials:", error);
                    resultsContainer.innerHTML = `<p class="text-red-400 p-4">Eroare la preluarea datelor financiare: ${error.message}</p>`;
                }
            };

            const filterAndRenderPayments = () => {
                const resultsContainer = document.getElementById('payments-list-results');
                const searchQuery = document.getElementById('financial-client-search').value.toLowerCase();

                const filteredPayments = state.financials.allPayments.filter(p =>
                    p.customer.toLowerCase().includes(searchQuery) ||
                    p.email.toLowerCase().includes(searchQuery)
                );

                if (filteredPayments.length === 0) {
                    resultsContainer.innerHTML = `<p class="text-center text-gray-400 py-4">Nu s-au găsit plăți pentru căutarea curentă.</p>`;
                    return;
                }

                const paymentCardsHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        ${filteredPayments.map(p => `
                            <div class="bg-gray-700/50 rounded-lg p-4 flex flex-col justify-between transition-all hover:bg-gray-700">
                                <div>
                                    <div class="flex justify-between items-start">
                                        <div>
                                            <p class="text-lg font-bold text-white truncate" title="${p.customer}">${p.customer}</p>
                                            <p class="text-xs text-gray-400 truncate" title="${p.email}">${p.email}</p>
                                        </div>
                                        <span class="text-xs font-semibold py-1 px-2 rounded-full ${p.method === 'Cash' ? 'bg-green-500/20 text-green-400' : 'bg-purple-500/20 text-purple-400'}">${p.method}</span>
                                    </div>
                                    <p class="text-2xl font-bold text-green-400 mt-2">${p.net.toFixed(2)} RON</p>
                                    <p class="text-sm text-gray-300 mt-2">${p.description}</p>
                                </div>
                                <div class="flex justify-between items-center text-xs text-gray-500 mt-4">
                                    <div class="flex items-center">
                                        <i data-lucide="calendar" class="h-3 w-3 mr-1.5"></i>
                                        <span>${new Date(p.date).toLocaleDateString('ro-RO', { day: '2-digit', month: 'long', year: 'numeric' })}</span>
                                    </div>
                                    ${p.method === 'Cash' ? `
                                    <button class="delete-payment-btn text-red-500 hover:text-red-400 p-1" data-id="${p.id}" title="Șterge Plata">
                                        <i data-lucide="trash-2" class="h-4 w-4"></i>
                                    </button>
                                    ` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                resultsContainer.innerHTML = paymentCardsHTML;
                lucide.createIcons();
            }

        });
    </script>
</body>

</html>
